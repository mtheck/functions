#!/usr/bin/env bash

[[ $__functions__ ]] && return

shopt -qo posix && return 126

readonly __functions=$BASH_SOURCE

declare -r LOG_LEVEL_NONE=_
declare -ri LOG_LEVEL_ERROR=0
declare -ri LOG_LEVEL_WARNING=1
declare -ri LOG_LEVEL_NOTE=2
declare -ri LOG_LEVEL_INFO=3
declare -ri LOG_LEVEL_DEBUG=4
declare -ri LOG_LEVEL_TRACE=5

declare -x LOG_{LEVEL,PREFIX,DATE,DATE_FORMAT,SOURCE,JSON,FILE}

_error () { log -$LOG_LEVEL_ERROR; }
_warn  () { log -$LOG_LEVEL_WARNING; }
_note  () { log -$LOG_LEVEL_NOTE; }
_msg   () { log -$LOG_LEVEL_INFO; }
_info  () { log -$LOG_LEVEL_INFO; }
_debug () { log -$LOG_LEVEL_DEBUG; }
_trace () { log -$LOG_LEVEL_TRACE; }

error () { log $LOG_LEVEL_ERROR "$@"; exit 1; }
warn  () { log $LOG_LEVEL_WARNING "$@"; }
note  () { log $LOG_LEVEL_NOTE "$@"; }
msg   () { log $LOG_LEVEL_INFO "$@"; }
debug () { log $LOG_LEVEL_DEBUG "$@"; }
trace () { log $LOG_LEVEL_TRACE "$@"; }

errorf () {
	[[ $# -gt 0 ]] || set "Invalid arguments"

	__caller

	( error @red+@ '{' @red+% "$CALLER_SOURCE@$CALLER_LINENO#$CALLER_FUNCNAME" @red+ '}' "$@" ) || :

	__caller_

	return 2
}

warnf () {
	[[ $# -gt 0 ]] || set "Unexpected arguments"

	__caller

	warn @yellow+@ '{' @yellow+% "$CALLER_SOURCE@$CALLER_LINENO#$CALLER_FUNCNAME" @yellow+ '}' "$@"

	__caller_
}

is_declared () {
	[[ $# -eq 1 ]] || errorf || return

	declare -p "$1" &>/dev/null
}

is_string () {
	[[ $# -eq 1 ]] || errorf || return

	declare -p "$1" &>/dev/null || return 3

	local s a=${!1@a}

	[[ $a == *A* ]] && { eval s='${'$1'[|]}'; [[ $s ]]; } && a=$s

	[[ $a != *[iaA]* ]]
}

is_integer () {
	[[ $# -eq 1 ]] || errorf || return

	declare -p "$1" &>/dev/null || return 3

	local s a=${!1@a}

	[[ $a == *A* ]] && { eval s='${'$1'[|]}'; [[ $s ]]; } && a=$s

	[[ $a == *i* ]]
}

is_scalar () {
	[[ $# -eq 1 ]] || errorf || return

	declare -p "$1" &>/dev/null || return 3

	local s a=${!1@a}

	[[ $a == *A* ]] && { eval s='${'$1'[|]}'; [[ $s ]]; } && a=$s

	[[ $a != *[aA]* ]]
}

is_array () {
	[[ $# -eq 1 ]] || errorf || return

	declare -p "$1" &>/dev/null || return 3

	local s a=${!1@a}

	[[ $a == *A* ]] && { eval s='${'$1'[|]}'; [[ $s ]]; } && a=$s

	[[ $a == *a* ]]
}

is_assoc () {
	[[ $# -eq 1 ]] || errorf || return

	declare -p "$1" &>/dev/null || return 3

	local s a=${!1@a}

	[[ $a == *A* ]] && { eval s='${'$1'[|]}'; [[ $s ]]; } && a=$s

	[[ $a == *A* ]]
}

is_struct () {
	[[ $# -eq 1 ]] || errorf || return

	declare -p "$1" &>/dev/null || return 3

	[[ ${!1@a} == *A* ]] || return

	local s; eval s='${'$1'[|]}'

	[[ $s ]]
}

is_pipe () {
	[[ $# -eq 1 ]] || errorf || return

	declare -F "$1"{,:,::,:__} >/dev/null
}

is_function () {
	[[ $# -eq 1 ]] || errorf || return

	declare -F "$1" >/dev/null
}

is_command () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $(type -P "$1") ]]
}

is_exec () {
	[[ $# -eq 1 ]] || errorf || return

	is_function "$1" || is_command "$1" || [[ $(type -t "$1") == builtin ]]
}

bool () {
	[[ $# -eq 1 ]] || errorf || return

	case $1 in
	1 | \
	true | TRUE | True | t | T | \
	yes | YES | Yes | y | Y | \
	on | ON | On)
	return 0
	;;
	0 | \
	false | FALSE | False | f | F | \
	no | NO | No | n | N | \
	off | OFF | Off)
	return 1
	;;
	esac
	return 3
}

color () {
	[[ $# -eq 1 ]] || errorf || return

	colorc "$1" && echo -n "$COLORC"
}

colorc () {
	[[ $# -eq 1 ]] || errorf || return

	local -A cc=(
		[none]=0
		[black]=30
		[red]=31
		[green]=32
		[yellow]=33
		[blue]=34
		[magenta]=35
		[cyan]=36
		[white]=37
	) sc=(
		[+]=1
		[-]=2
		[/]=3
		[=]=4
		[%]=7
	)

	COLORC=

	local i code list elem name fmt num

	list=$1

	while [[ $list ]]; do
		elem=${list%%,*}
		list=${list:${#elem}}

		name=${elem%%[![:word:]]*}
		fmt=${elem:${#name}}

		if [[ $name ]]; then
			num=${cc[$name]}

			if [[ $num ]]; then
				[[ $list ]] && ((num+=10))
				[[ $code ]] && code+=\;
				code+=$num
			else
				code=
				break
			fi
		fi

		for ((i=0; i<${#fmt}; i++)); do
			num=${sc[${fmt:i:1}]}

			if [[ $num ]]; then
				[[ $code ]] && code+=\;
				code+=$num
			else
				code=
				break 2
			fi
		done

		list=${list#,}
	done

	[[ $code ]] || return

	COLORC=$'\e['$code\m
}

echoc () {
	local nl
	[[ $1 == -n ]] && nl=$1 && shift

	local color base code

	if [[ $ECHOC ]]; then
		bool "$ECHOC" && color=_
	else
		[[ -t 1 ]] && color=_
	fi

	if [[ $ECHOC_BASE ]] && colorc "$ECHOC_BASE"; then
		base=$COLORC
	fi

	local out space spec

	while [[ $# -gt 0 ]]; do
		spec=${1#@}; spec=${spec#:}; spec=${spec%@}

		if [[ $1 == @* ]] && { [[ ! $spec ]] || colorc "$spec"; }; then
			[[ $spec ]] && code=$COLORC
			[[ $1 == @:* ]] && base=$code
			[[ $1 == *@ ]] && space=_ || space=
		else
			if [[ ! $out ]]; then
				if [[ $color ]]; then
					out+=$'\e'[0m
					[[ $base ]] && out+=$base
				fi
			else
				[[ $space ]] && out+=' '
			fi

			if [[ $code ]]; then
				[[ $color ]] && out+=$code
			fi

			out+=$1

			if [[ $code ]]; then
				if [[ $color ]]; then
					out+=$'\e'[0m
					[[ $base ]] && out+=$base
				fi
				code=
			fi

			space=_
		fi

		shift
	done

	[[ $color ]] && out+=$'\e'[0m

	echo $nl "$out" || :
}

echoe () {
	echoc "$@" >&2 || :
}

log () {
	[[ $# -ge 1 ]] || errorf || return

	local level=$1 test drop; shift

	valid_int "$level" || errorf "Invalid log level" || return

	if [[ $level == -* ]] ; then
		test=_
		level=${level##*-}
	fi

	[[ $level -le 5 ]] || errorf "Unknown log level" || return

	local log_level=$LOG_LEVEL

	if [[ $log_level == _ ]]; then
		drop=_
	else
		valid_uint "$log_level" || log_level=3

		[[ $log_level -lt $level ]] && drop=_
	fi

	if [[ $test ]]; then
		[[ $drop ]] && return 1
		return 0
	fi
	[[ $drop ]] && return 0

	local levels=(
		error:Error:red
		warning:Warning:yellow
		note:Note:green
		info::cyan
		debug:DEBUG:
		trace:TRACE:
	)

	local -A field; local args=() value json def=${levels[$level]}; local code header=${def%:*} color=${def##*:}; code=${header%:*} header=${header#*:}

	bool "$LOG_JSON" && json=_

	if [[ $json ]] || bool "$LOG_DATE" || [[ ! $LOG_DATE && $log_level -ge $LOG_LEVEL_DEBUG ]]; then
		value=
		[[ $LOG_DATE_FORMAT == %s ]] && value=$EPOCHSECONDS
		[[ ! $value && $LOG_DATE_FORMAT ]] && value=$(date +"$LOG_DATE_FORMAT")
		[[ $value ]] || value=$(date -In)

		field[ts]=$value
	fi

	if bool "$LOG_SOURCE" || [[ ! $LOG_SOURCE && $log_level -ge $LOG_LEVEL_TRACE ]]; then
		__caller

		field[pid]=$BASHPID field[source]=$CALLER_SOURCE@$CALLER_LINENO

		__caller_
	fi

	if [[ $json ]]; then
		json={

		value=${field[ts]} && [[ $value ]] && jquote:: value && json+='"ts":'"$value",
		value=${field[pid]} && [[ $value ]] && json+='"pid":"'"$value"'"',
		value=${field[source]} && [[ $value ]] && jquote:: value && json+='"source":'"$value",

		json+='"level":"'$code'"',

		jquote: value "$(echoc "$@")"
		json+='"msg":'"$value"}

		args=("$json")
	else
		if [[ ! $LOG_FILE ]]; then
			local log_prefix_opt log_prefix=$LOG_PREFIX prefix

			if [[ $log_prefix == [+-]* ]]; then
				log_prefix_opt=${log_prefix:0:1}
				log_prefix=${log_prefix#?}
			fi
			if [[ $log_prefix == _ ]]; then
				log_prefix=
			elif [[ ! $log_prefix ]]; then
				log_prefix='>>>'
			fi

			[[ -t 2 && $log_prefix_opt != + ]] || prefix=$log_prefix

			[[ $log_level -ge $LOG_LEVEL_DEBUG && $log_prefix_opt != - ]] && prefix=$log_prefix

			[[ $prefix ]] && args+=("$prefix")
		fi

		value=${field[ts]} && [[ $value ]] && args+=("[$value]")
		value=${field[pid]} && [[ $value ]] && args+=("$value")
		value=${field[source]} && [[ $value ]] && args+=("{$value}")

		[[ $color ]] || color=none

		if [[ $header ]]; then
			local header_color=$color sep_color=$color

			if [[ $color != none ]]; then
				header_color+=+=
				sep_color+=+
			fi

			args+=(@$header_color@ "$header" @$sep_color :)
		fi

		args+=(@:$color@ "$@")
	fi

	[[ $LOG_FILE ]] && ECHOC=0 echoc "${args[@]}" >> "$LOG_FILE" && return 0

	ECHOC_BASE=none echoe "${args[@]}"
}

ask () {
	local question=$1; shift || :

	[[ $question ]] || question=?

	local -A answers
	local answer choose reply

	for answer; do
		[[ $answer ]] || continue

		answers[$answer]=_
	done

	[[ $# -gt 0 ]] && choose=" ($(IFS=\|; echo "$*"))"

	while :; do
		echoe -n @yellow+ "$question$choose: "
		read reply

		[[ $# -gt 0 ]] || break
		[[ $reply && ${answers[$reply]} ]] && break
	done

	echo "$reply"
}

confirm () {
	[[ $# -eq 0 ]] || errorf || return

	[[ $(ask "Are you sure you want to continue?" y n) == y ]]
}

valid_name () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 =~ ^[[:alpha:]_][[:alnum:]_]*$ ]]
}

valid_identifier () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 =~ ^[[:alpha:]]([[:alnum:]-]*[[:alnum:]])?$ ]]
}

valid_field () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 && $1 != *\|* ]]
}

valid_int () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 =~ ^[-+]?[[:digit:]]+$ ]]
}

valid_uint () {
	[[ $# -eq 1 ]] || errorf || return

	valid_int "$1" && [[ $1 != -* ]]
}

valid_float () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 =~ ^[-+]?[[:digit:]]*\.?[[:digit:]]+([eE][[:digit:]]+)?$ ]]
}

valid_ufloat () {
	[[ $# -eq 1 ]] || errorf || return

	valid_float "$1" && [[ $1 != -* ]]
}

valid_bool () {
	[[ $# -eq 1 ]] || errorf || return

	bool "$1" || [[ $? -ne 3 ]]
}

require_command () {
	[[ $# -eq 1 ]] || errorf || return

	is_command "$1" || error "Command required: $1"
}

port_opened () {
    [[ $# -ge 1 && $# -le 3 ]] || errorf || return

    local port=$1 addr=${2:-127.0.0.1} proto=${3:-tcp}

    valid_uint "$port" || errorf "Invalid port: $port" || return

    [[ $addr =~ ^[[:digit:]]+(\.[[:digit:]]+){3}$ ]] || errorf "Invalid address: $addr" || return

    [[ $proto == tcp || $proto == udp ]] || errorf "Invalid protocol: $proto" || return

    { : > /dev/$proto/$addr/$port; } &>/dev/null || return 1
}

contains () {
	[[ $# -ge 1 ]] || errorf || return

	local val=$1 elem; shift

	for elem; do
		[[ $elem == "$val" ]] && return 0
	done
	return 1
}

selects () {
	[[ $# -ge 1 ]] || errorf || return

	[[ $# -gt 1 ]] || return 0

	contains "$@"
}

concat () {
	[[ $# -ge 1 ]] || errorf || return

	local sep=$1 str set elem; shift

	for elem; do
		[[ $set ]] && str+=$sep || set=_
		str+=$elem
	done

	echo "$str"
}

push () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	local _x_arr=$1 _x_str=$2 _x_delim=$3 && _var "$1" || return

	! _debug || is_array "$_x_arr" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	[[ $# -ge 3 ]] || _x_delim=,

	local _x_out=() _x_slen=${#_x_str} _x_dlen=${#_x_delim} _x_pos=0 _x_cur=

	eval _x_out='("${'$_x_arr'[@]}")'

	while [[ $_x_pos -lt $_x_slen ]]; do
		if [[ $_x_dlen -eq 0 ]]; then
			_x_out+=("${_x_str:_x_pos++:1}")
		elif [[ ${_x_str:_x_pos:_x_dlen} == "$_x_delim" ]]; then
			_x_out+=("$_x_cur")
			_x_cur=
			((_x_pos+=_x_dlen))
		else
			_x_cur+=${_x_str:_x_pos++:1}
		fi
	done

	[[ $_x_cur ]] && _x_out+=("$_x_cur")

	eval $_x_arr='("${'_x_out'[@]}")'
}

-a () { [[ $# -eq 1 ]] || errorf || return; [[ -a $1 ]]; }
-b () { [[ $# -eq 1 ]] || errorf || return; [[ -b $1 ]]; }
-c () { [[ $# -eq 1 ]] || errorf || return; [[ -c $1 ]]; }
-d () { [[ $# -eq 1 ]] || errorf || return; [[ -d $1 ]]; }
-e () { [[ $# -eq 1 ]] || errorf || return; [[ -e $1 ]]; }
-f () { [[ $# -eq 1 ]] || errorf || return; [[ -f $1 ]]; }
-g () { [[ $# -eq 1 ]] || errorf || return; [[ -g $1 ]]; }
-h () { [[ $# -eq 1 ]] || errorf || return; [[ -h $1 ]]; }
-k () { [[ $# -eq 1 ]] || errorf || return; [[ -k $1 ]]; }
-p () { [[ $# -eq 1 ]] || errorf || return; [[ -p $1 ]]; }
-r () { [[ $# -eq 1 ]] || errorf || return; [[ -r $1 ]]; }
-s () { [[ $# -eq 1 ]] || errorf || return; [[ -s $1 ]]; }
-t () { [[ $# -eq 1 ]] || errorf || return; [[ -t $1 ]]; }
-u () { [[ $# -eq 1 ]] || errorf || return; [[ -u $1 ]]; }
-w () { [[ $# -eq 1 ]] || errorf || return; [[ -w $1 ]]; }
-x () { [[ $# -eq 1 ]] || errorf || return; [[ -x $1 ]]; }
-G () { [[ $# -eq 1 ]] || errorf || return; [[ -G $1 ]]; }
-L () { [[ $# -eq 1 ]] || errorf || return; [[ -L $1 ]]; }
-N () { [[ $# -eq 1 ]] || errorf || return; [[ -N $1 ]]; }
-O () { [[ $# -eq 1 ]] || errorf || return; [[ -O $1 ]]; }
-S () { [[ $# -eq 1 ]] || errorf || return; [[ -S $1 ]]; }
-o () { [[ $# -eq 1 ]] || errorf || return; [[ -o $1 ]]; }
-v () { [[ $# -eq 1 ]] || errorf || return; [[ -v $1 ]]; }
-R () { [[ $# -eq 1 ]] || errorf || return; [[ -R $1 ]]; }
-z () { [[ $# -eq 1 ]] || errorf || return; [[ -z $1 ]]; }
-n () { [[ $# -eq 1 ]] || errorf || return; [[ -n $1 ]]; }

-ef () { [[ $# -eq 2 ]] || errorf || return; [[ $1 -ef $2 ]]; }
-nt () { [[ $# -eq 2 ]] || errorf || return; [[ $1 -nt $2 ]]; }
-ot () { [[ $# -eq 2 ]] || errorf || return; [[ $1 -ot $2 ]]; }

-eq:[?--] () { [[ $1 -eq $2 ]]; }
-ne:[?--] () { [[ $1 -ne $2 ]]; }
-lt:[?--] () { [[ $1 -lt $2 ]]; }
-le:[?--] () { [[ $1 -le $2 ]]; }
-gt:[?--] () { [[ $1 -gt $2 ]]; }
-ge:[?--] () { [[ $1 -ge $2 ]]; }

_eq:[?--] () { [[ $1 == "$2" ]]; }
_ne:[?--] () { [[ $1 != "$2" ]]; }
_lt:[?--] () { [[ $1 < $2 ]]; }
_le:[?--] () { [[ $1 < $2 ]] || [[ $1 == "$2" ]]; }
_gt:[?--] () { [[ $1 > $2 ]]; }
_ge:[?--] () { [[ $1 > $2 ]] || [[ $1 == "$2" ]]; }

_pe:[?--] () { [[ $1 == $2 ]]; }
_pn:[?--] () { [[ $1 != $2 ]]; }
_re:[?--] () { [[ $1 =~ $2 ]]; }
_rn:[?--] () { [[ ! $1 =~ $2 ]]; }

_true:[?-] () { bool "$1"; }
_false:[?-] () { bool "$1" && return 1; [[ $? -eq 1 ]] && return 0; return 2; }

add:[---] () { output $(($1+$2)); }
sub:[---] () { output $(($1-$2)); }
mul:[---] () { output $(($1*$2)); }
div:[---] () { output $(($1/$2)); }
mod:[---] () { output $(($1%$2)); }
exp:[---] () { output $(($1**$2)); }

len:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	= $1 ${#2}
}

count:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	eval $1='${#'$2'[@]}'
}

index:[-@] () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_key=$3 && [[ $3 ]] || _x_key=0

	eval $1='${'$2'[$_x_key]}'
}

total:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_total=0 _x_val _x_vals=()

	eval _x_vals='("${'$2'[@]}")' && [[ ${#_x_vals[@]} -gt 0 ]] || errorf "Array is empty" || return

	for _x_val in "${_x_vals[@]}"; do
		_x_total=$((_x_total+_x_val))
	done

	eval $1=\$_x_total
}

min:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_min _x_val _x_vals=()

	eval _x_vals='("${'$2'[@]}")' && [[ ${#_x_vals[@]} -gt 0 ]] || errorf "Array is empty" || return

	for _x_val in "${_x_vals[@]}"; do
		[[ ! $_x_min || $_x_val -lt $_x_min ]] && _x_min=$_x_val
	done

	eval $1=\$_x_min
}

max:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_max _x_val _x_vals=()

	eval _x_vals='("${'$2'[@]}")' && [[ ${#_x_vals[@]} -gt 0 ]] || errorf "Array is empty" || return

	for _x_val in "${_x_vals[@]}"; do
		[[ ! $_x_max || $_x_val -gt $_x_max ]] && _x_max=$_x_val
	done

	eval $1=\$_x_max
}

avg:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_avg=0 _x_val _x_vals=()

	eval _x_vals='("${'$2'[@]}")' && [[ ${#_x_vals[@]} -gt 0 ]] || errorf "Array is empty" || return

	for _x_val in "${_x_vals[@]}"; do
		_x_avg=$((_x_avg+_x_val))
	done

	_x_avg=$((_x_avg/${#_x_vals[@]}))

	eval $1=\$_x_avg
}

quote:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	eval $1='${2@Q}'
}

jquote:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_str=${2//\\/\\\\}

	_x_str="\"${_x_str//\"/\\\"}\""

	eval $1=\$_x_str
}

pad:[--] () {
	[[ $# -ge 3 && $# -le 4 ]] || errorf || return

	_var "$1" || return

	local _x_str=$2 _x_len=$3 _x_pad=$4

	valid_uint "$_x_len" || errorf "Invalid pad length" || return

	[[ $_x_pad ]] || _x_pad=' '

	local _x_pad_c _x_pad_len=${#_x_pad} _x_add_len=$((_x_len-${#_x_str}))

	if [[ $_x_add_len -gt 0 ]]; then
		for ((_x_pad_c=$((_x_add_len/_x_pad_len)); _x_pad_c>0; _x_pad_c--)); do
			_x_str+=$_x_pad
		done
		_x_add_len=$((_x_len-${#_x_str})) && [[ $_x_add_len -gt 0 ]] && _x_str+=${_x_pad:0:_x_add_len}
	fi

	eval $1=\$_x_str
}

trim:[--] () {
	_trim _ "$@"
}

triml:[--] () {
	_trim - "$@"
}

trimr:[--] () {
	_trim + "$@"
}

_trim () {
	[[ $# -ge 3 && $# -le 4 ]] || errorf || return

	_var "$2" || return

	local _x_side=$1 _x_var=$2 _x_str=$3 _x_chars=$4

	[[ $# -gt 3 ]] || _x_chars=$' \t\n'

	if [[ $_x_chars ]]; then
		local _x_i _x_len

		if [[ $_x_side == - || $_x_side == _ ]]; then
			_x_len=${#_x_str}
			for ((_x_i=0; _x_i<_x_len; _x_i++)); do
				[[ $_x_chars == *"${_x_str:_x_i:1}"* ]] || break
			done
			_x_str=${_x_str:_x_i}
		fi

		if [[ $_x_side == + || $_x_side == _ ]]; then
			_x_len=${#_x_str}
			for ((_x_i=_x_len; _x_i>0; _x_i--)); do
				[[ $_x_chars == *"${_x_str:_x_i-1:1}"* ]] || break
			done
			_x_str=${_x_str:0:_x_i}
		fi
	fi

	eval $_x_var=\$_x_str
}

upper:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	= $1 "${2^^}"
}

lower:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	= $1 "${2,,}"
}

upperf:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	= $1 "${2^}"
}

lowerf:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	= $1 "${2,}"
}

file_dir:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_file=$2 _x_root

	while [[ $_x_file == */ ]]; do
		_x_file=${_x_file:0:-1}
	done
	while [[ $_x_file == *[!/] ]]; do
		_x_file=${_x_file:0:-1}
	done
	while [[ $_x_file == */ ]]; do
		_x_file=${_x_file:0:-1}
	done

	if [[ ! $_x_file ]]; then
		_x_root=${1%%[!/]*}

		[[ $_x_root && $_x_root != // ]] && _x_root=/

		_x_file=$_x_root
	fi

	[[ $_x_file ]] || _x_file=.

	= $1 "$_x_file"
}

file_name:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_file=$2 _x_root

	while [[ $_x_file == */ ]]; do
		_x_file=${_x_file:0:-1}
	done

	_x_file=${_x_file##*/}

	if [[ ! $_x_file ]]; then
		_x_root=${1%%[!/]*}

		[[ $_x_root && $_x_root != // ]] && _x_root=/

		_x_file=$_x_root
	fi

	= $1 "$_x_file"
}

file_base:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_file_=$2

	file_name: _x_file_ "$_x_file_"

	_x_file_=${_x_file_%.*}

	= $1 "$_x_file"
}

file_ext:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_file_=$2

	file_name: _x_file_ "$_x_file_"

	_x_file_=${_x_file_##*.}

	= $1 "$_x_file"
}

duration:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_duration=$2

	local -A _x_units=(
		[s]=1
		[m]=60
		[h]=3600
	)

	local -i _x_seconds=0

	local _x_num _x_unit _x_factor

	while [[ $_x_duration ]]; do
		_x_num=${_x_duration%%[!0-9]*}

		[[ $_x_num ]] || return 1

		_x_duration=${_x_duration:${#_x_num}}
		_x_unit=${_x_duration%%[[:digit:]]*}

		[[ $_x_unit ]] || _x_unit=s

		_x_duration=${_x_duration:${#_x_unit}}
		_x_factor=${_x_units[$_x_unit]}

		[[ $_x_factor ]] || return 1

		_x_seconds=$((_x_seconds+_x_num*_x_factor))
	done

	= $1 $_x_seconds
}

filter:[@@] () {
	[[ $# -ge 4 ]] || errorf || return

	_var "$1" && _var "$2" || return

	local _x_var=$1 _x_arr=$2 _x_op=$3 _x_type=_ _x_filter=$4; shift 4

	if _debug; then
		is_array "$_x_var" || [[ $? -eq 1 ]] || warnf "Output variable is not an array"
		is_array "$_x_arr" || warnf "Variable is not an array"
	fi

	if [[ ${#_x_op} -gt 1 ]]; then
		_x_type=${_x_op:1}
		_x_op=${_x_op:0:1}

		[[ $_x_type == [_=~@] ]] || errorf "Invalid filter operator" || return

		if [[ $_x_type == @ ]]; then
			! _debug || is_exec "$_x_filter" || warnf "Filter command not defined"
		else
			[[ $# -eq 0 ]] || errorf || return
		fi
	fi

	[[ $_x_op == [-+] ]] || errorf "Invalid filter operator" || return

	local _x_out=() _x_match _x_found _x_arg _x_args=() _x_elems=() _x_elem

	eval _x_elems='("${'$_x_arr'[@]}")'

	for _x_elem in "${_x_elems[@]}"; do
		_x_match=

		case $_x_type in
		'_')
			if [[ $_x_elem == "$_x_filter" ]]; then
				_x_match=_
			fi
			;;
		'=')
			if [[ $_x_elem == $_x_filter ]]; then
				_x_match=_
			fi
			;;
		'~')
			if [[ $_x_elem =~ $_x_filter ]]; then
				_x_match=_
			else
				[[ $? -eq 1 ]] || errorf "Invalid filter regular expression" || return
			fi
			;;
		'@')
			_x_args=()
			_x_found=

			for _x_arg; do
				if [[ $_x_arg == *{}* ]]; then
					_x_arg=${_x_arg//\{\}/"$_x_elem"}
					_x_found=_
				fi
				_x_args+=("$_x_arg")
			done
			[[ $_x_found ]] || _x_args+=("$_x_elem")

			if $_x_filter "${_x_args[@]}" >/dev/null; then
				_x_match=_
			fi
			;;
		esac

		if [[ $_x_match ]]; then
			[[ $_x_op == - ]] && continue
		else
			[[ $_x_op == + ]] && continue
		fi

		_x_out+=("$_x_elem")
	done

	eval $_x_var='("${'_x_out'[@]}")'
}

map:[@@] () {
	[[ $# -ge 3 ]] || errorf || return

	_var "$1" && _var "$2" || return

	local _x_var=$1 _x_arr=$2 _x_exec=$3; shift 3

	if _debug; then
		is_array "$_x_var" || [[ $? -eq 1 ]] || warnf "Output variable is not an array"
		is_array "$_x_arr" || warnf "Variable is not an array"
		is_exec "$_x_exec" || warnf "Map command not defined"
	fi

	local _x_out=() _x_found _x_pipe _x_arg _x_args=() _x_elems=() _x_elem_

	eval _x_elems='("${'$_x_arr'[@]}")'

	is_pipe "$_x_exec" && _x_pipe=_

	for _x_elem_ in "${_x_elems[@]}"; do
		_x_args=()
		_x_found=

		for _x_arg; do
			if [[ $_x_arg == *{}* ]]; then
				_x_arg=${_x_arg//\{\}/"$_x_elem_"}
				_x_found=_
			fi
			_x_args+=("$_x_arg")
		done

		if [[ ! $_x_found ]]; then
			if [[ $_x_pipe ]]; then
				_x_args=("$_x_elem_" "${_x_args[@]}")
			else
				_x_args+=("$_x_elem_")
			fi
		fi

		if [[ $_x_pipe ]]; then
			${_x_exec}: _x_elem_ "${_x_args[@]}"
		else
			_x_elem_=$($_x_exec "${_x_args[@]}") || return $?
		fi

		_x_out+=("$_x_elem_")
	done

	eval $_x_var='("${'_x_out'[@]}")'
}

sep:[@-] () {
	[[ $# -ge 2 && $# -le 5 ]] || errorf || return

	_var "$1" || return

	local _x_str=$2 _x_regex=$3 _x_limit=0 _x_keep=

	! _debug || is_array "$1" || [[ $? -eq 1 ]] || warnf "Output variable is not an array"

	[[ $# -lt 3 ]] && _x_regex=\\s+

	if [[ $# -ge 4 ]]; then
		_x_limit=$4

		valid_uint "$_x_limit" || errorf "Invalid limit number" || return
	fi
	if [[ $# -ge 5 ]]; then
		if bool "$5"; then
			_x_keep=_
		elif [[ $? -ne 1 ]]; then
			errorf "Invalid boolean for keep" || return
		fi
	fi

	local _x_out=() _x_count=0 _x_sep _x_rem _x_len

	while :; do
		((++_x_count))

		if [[ $_x_limit -eq 0 || $_x_count -lt $_x_limit ]] && [[ $_x_str =~ ($_x_regex).* ]]; then
			_x_sep=${BASH_REMATCH[1]}
			_x_rem=${BASH_REMATCH[0]}

			[[ $_x_sep ]] || _x_rem=${_x_rem:1}

			_x_len=$((${#_x_str}-${#_x_rem}))

			_x_out+=("${_x_str:0:_x_len}")
			[[ $_x_keep ]] && _x_out+=("$_x_sep")

			_x_str=${_x_str:_x_len+${#_x_sep}}
		else
			[[ $? -eq 1 ]] || errorf "Invalid separator regular expression" || return

			_x_out+=("$_x_str")
			_x_str=
		fi

		[[ $_x_str ]] || break
	done

	eval $1='("${'_x_out'[@]}")'
}

tie:[-@] () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	_var "$1" && _var "$2" || return

	local _x_sep=$3

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_out _x_set _x_elems=() _x_elem

	eval _x_elems='("${'$2'[@]}")'

	for _x_elem in "${_x_elems[@]}"; do
		[[ $_x_set ]] && _x_out+=$_x_sep || _x_set=_
		_x_out+=$_x_elem
	done

	eval $1=\$_x_out
}

reverse:[@@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	if _debug; then
		is_array "$1" || [[ $? -eq 1 ]] || warnf "Output variable is not an array"
		is_array "$2" || warnf "Variable is not an array"
	fi

	local _x_i _x_tmp _x_out=()

	eval _x_out='("${'$2'[@]}")'

	_x_i=$((${#_x_out[@]}/2))

	while [[ $_x_i -gt 0 ]]; do
		_x_tmp=${_x_out[-_x_i]}
		_x_out[-_x_i]=${_x_out[_x_i-1]}
		_x_out[--_x_i]=$_x_tmp
	done

	eval $1='("${'_x_out'[@]}")'
}

tmp_file () {
	[[ $# -le 1 ]] || errorf || return

	local tmp tmpdir_arg=--tmpdir
	if [[ $# -ge 1 ]]; then
		[[ -d $1 ]] || errorf "Invalid target directory: $1" || return
		tmpdir_arg+==$1
	fi

	tmp=$(mktemp "$tmpdir_arg" --suffix .tmp tmp_$(uuidgen)_XXXXXXXX)

	_trace && trace "Temporary file: $tmp"

	defer rm -f "$tmp"

	TMP_FILE=$tmp
}

tmp_dir () {
	[[ $# -le 1 ]] || errorf || return

	local tmp tmpdir_arg=--tmpdir
	if [[ $# -ge 1 ]]; then
		[[ -d $1 ]] || errorf "Invalid target directory: $1" || return
		tmpdir_arg+==$1
	fi

	tmp=$(mktemp "$tmpdir_arg" --directory tmp_$(uuidgen)_XXXXXXXX)

	_trace && trace "Temporary directory: $tmp"

	defer rm -rf "$tmp"

	TMP_DIR=$tmp
}

ephemeral_port () {
    [[ $# -eq 0 ]] || errorf || return

    require_command nc

    local port

    coproc:run __ephemeral_port__ 'nc -lv 127.0.0.1 0 2>&1' || return

    if coproc:read_line __ephemeral_port__; then
		port=${COPROC_DATA##*[![:digit:]]}
    fi

	coproc:kill __ephemeral_port__ || :

	[[ $port && $port != *[![:digit:]]* ]] || return

    EPHEMERAL_PORT=$port
}

run () {
	[[ $# -gt 0 ]] || errorf || return

	[[ $# -eq 1 && $1 == *' '* && $SHELL ]] && set -- "$SHELL" -c "$1"

	_trace && trace "Running: $*"

	"$@"
}

job:run () {
	[[ $# -ge 1 ]] || errorf || return

	[[ $1 == - ]] || errorf "Invalid job name" || return

	local name=$1; shift

	[[ $# -eq 1 && $1 == *' '* && $SHELL ]] && set -- "$SHELL" -c "$1"

	set -m

	"$@" &

	local pid=$(jobs -p % 2>/dev/null)

	[[ $pid ]] || return

	_trace && trace "Running job $pid: $*"

	defer job:kill $pid
}

job:kill () {
	[[ $# -le 1 ]] || errorf || return

	[[ $# -eq 0 ]] && set %

	local pid spec

	if valid_uint "$1"; then
		pid=$1

		local n pids=($(jobs -p))
		for ((n=1; n<=${#pids[@]}; n++)); do
			if [[ ${pids[n-1]} == $pid ]]; then
				spec=%$n
				break
			fi
		done
	else
		pid=$(jobs -p "$1" 2>/dev/null) && spec=$1
	fi

	if [[ ! $spec ]]; then
		_trace && trace "Job process not found: $1"

		return 0
	fi

	_trace && trace "Killing job process: $pid"

	kill "$spec" 2>/dev/null
	wait -f "$spec" 2>/dev/null
}

coproc:run () {
	[[ $# -gt 1 && $1 ]] || errorf || return

	declare -g -A __coproc

	[[ ${__coproc[$1]} -gt 0 ]] && return

	valid_name "$1" || errorf "Invalid coprocess name" || return

	local name=$1; shift

	[[ $# -eq 1 && $1 == *' '* && $SHELL ]] && set -- "$SHELL" -c "$1"

	set -m

	coproc "$@"

	__coproc[$name]=$COPROC_PID
	__coproc[$name:0]=${COPROC[0]}
	__coproc[$name:1]=${COPROC[1]}

	_trace && trace "Running coprocess $COPROC_PID $name: $*"

	defer coproc:kill $name
}

coproc:kill () {
	[[ $# -eq 1 && $1 ]] || errorf || return

	local pid=${__coproc[$1]}

	[[ $pid ]] || errorf "Unknown coprocess" || return

	[[ $pid -eq 0 ]] && return

	unset -v __coproc[$1:0] __coproc[$1:1]

	__coproc[$1]=0

	job:kill $pid
}

coproc:write () {
	[[ $# -gt 1 ]] || errorf || return

	local fd=${__coproc[$1:1]}; shift

	[[ $fd ]] || errorf "Unknown coprocess" || return

	if [[ $# -eq 0 ]]; then
		cat >&$fd
		return
	fi

	while [[ $# -gt 0 ]]; do
		echo -n "$1" >&$fd
		shift
	done
}

coproc:read_line () {
	[[ $# -eq 1 ]] || errorf || return

	local fd=${__coproc[$1:0]}; shift

	[[ $fd ]] || errorf "Unknown coprocess" || return

	IFS= read -r COPROC_DATA <&$fd || errorf "Failed reading line" || return
}

coproc:read_field () {
	[[ $# -eq 1 ]] || errorf || return

	local fd=${__coproc[$1:0]}; shift

	[[ $fd ]] || errorf "Unknown coprocess" || return

	local size end

	IFS= read -r size <&$fd || errorf "Failed reading field size" || return

	valid_uint "$size" || errorf "Invalid field size read: $size" || return

	IFS= read -r -d '' -n "$size" COPROC_DATA <&$fd || errorf "Failed reading field value" || return

	IFS= read -r end <&$fd || errorf "Failed reading field end" || return

	[[ ${#end} -eq 0 ]] || errorf "Unexpected data after field value" || return
}

@ () {
	local _x_var__

	__=_ @: _x_var__ "$@"

	local IFS=$'\n'

	echo "${_x_var__[*]}"
}

@- () {
	local _x_var__

	__=- @: _x_var__ "$@"

	local IFS=$'\n'

	echo "${_x_var__[*]}"
}

@@ () {
	local _x_var__

	__=@ @: _x_var__ "$@"

	local IFS=$'\n'

	echo "${_x_var__[*]}"
}

-@ () {
	local _x_var__ _x_ifs IFS=$IFS

	while IFS= read -r _x_var__; do
		__=- @: _x_var__ "$_x_var__" "$@"

		_x_ifs=$IFS IFS=$'\n'

		echo "${_x_var__[*]}"

		IFS=$_x_ifs
	done
}

-@@ () {
	local _x_var__

	readarray -t _x_var__

	__=@ @: _x_var__ _x_var__ "$@"

	local IFS=$'\n'

	echo "${_x_var__[*]}"
}

-@@: () {
	local _x_var=$1 _x_var__; shift || errorf || return

	readarray -t _x_var__

	__=@ @: "$_x_var" _x_var__ "$@"
}

@@: () {
	__=@ @: "$@"
}

@:: () {
	__=@ @: "$1" "$@"
}

@: () {
	[[ $# -ge 3 ]] || errorf || return

	_var "$1" || return

	local _x_var=$1 _x_vals=("$2"); shift 2

	local __=$__ _x_out__=() _x_in__=() _x_elems=() _x_sls=() _x_sls_x=() _x_vals_x=() _x_val _x_i _x_l _x_pos _x_len _x_size _x_depth _x_sld _x_sll _x_spec _x_fct _x_sep _x_arg _x_args=() _x_pipe=() _x_err _x_errexit _x_funcname=$CALLER_FUNCNAME_

	[[ ! $__ || ${BASH_SOURCE[1]} != "$__functions" ]] && __=_

	while [[ ${#@} -gt 0 ]]; do
		_x_spec=$1; shift

		if [[ $_x_spec == @* && ( ${_x_spec:1} != *[!-]* || ${_x_spec:1} != *[!+]* ) ]]; then
			_x_arg=$((${#_x_spec}-1))
			[[ $_x_spec == *- ]] && _x_arg=-$_x_arg

			_x_pipe+=(@ 1 $_x_arg)

			continue
		fi

		_x_fct=${_x_spec%%\[*}

		[[ $_x_fct ]] || errorf "Missing function name in argument: $_x_spec" || return

		is_pipe "$_x_fct" || errorf "Unknown pipe function: $_x_fct" || return

		_x_spec=${_x_spec:${#_x_fct}} _x_args=()

		if [[ $_x_spec ]]; then
			while :; do
				_x_sep=${_x_spec:0:1}
				_x_spec=${_x_spec:1}

				[[ $_x_sep == \] ]] && break

				if [[ $_x_sep == , ]]; then
					_x_args+=("$_x_arg")
				else
					[[ $_x_sep == \[ && ${#_x_args[@]} -eq 0 ]] || errorf "Missing comma separator after argument of function:" $_x_fct ${_x_args[*]} $_x_arg || return
				fi

				if [[ ! $_x_spec ]]; then
					_x_arg=$1; shift || errorf "Missing isolated argument of function:" $_x_fct ${_x_args[*]} || return

					_x_spec=$1; shift || errorf "Missing argument after isolated argument of function:" $_x_fct ${_x_args[*]} $_x_arg || return

					[[ $_x_spec == \]* ]] && _x_args+=("$_x_arg") && _x_arg=

					continue
				fi

				_x_arg=${_x_spec%%[,\]]*}
				_x_spec=${_x_spec:${#_x_arg}}
			done

			[[ ! $_x_spec ]] || errorf "Unexpected content '$_x_spec' after arguments of function:" $_x_fct ${_x_args[*]} || return

			[[ $_x_arg ]] && _x_args+=("$_x_arg")
		fi

		_x_pipe+=("$_x_fct" ${#_x_args[@]} "${_x_args[@]}")
	done

	shopt -qo errexit && _x_errexit=_

	if [[ $__ == - ]] || { [[ $__ == _ ]] && "$_x_pipe":__ _ -; }; then :; else
		_var "$_x_vals" || return

		eval _x_vals='("${'$_x_vals'[@]}")'
	fi

	_x_depth=1 _x_sls=(-1 ${#_x_vals[@]})

	while [[ ${#_x_pipe[@]} -gt 0 ]]; do
		_x_fct=${_x_pipe[0]}
		_x_len=${_x_pipe[1]}
		_x_args=("${_x_pipe[@]:2:_x_len}")
		_x_pipe=("${_x_pipe[@]:2+_x_len}")

		if [[ $_x_fct == @ ]]; then
			if [[ $_x_args -lt 0 ]]; then
				[[ -$_x_depth -lt $_x_args ]] && _x_depth=$((_x_depth+_x_args)) || _x_depth=1
			else
				[[ $_x_depth -gt $_x_args ]] && _x_depth=$((_x_args+1))
			fi
			continue
		fi

		"$_x_fct":__ @ - && _x_sld=$((_x_depth+1)) || _x_sld=

		_x_pos=0 _x_l=${#_x_sls[@]}

		for ((_x_i=0; _x_i<_x_l; _x_i++)); do
			_x_len=${_x_sls[_x_i]}

			if [[ $_x_len -lt 0 ]]; then
				[[ -$_x_len -lt $_x_depth ]] && _x_sls_x+=($_x_len) && continue
				[[ -$_x_len -gt $_x_depth ]] || continue

				_x_len=0

				while :; do
					_x_sll=${_x_sls[_x_i+1]}

					if [[ $_x_sll -lt 0 ]]; then
						[[ -$_x_sll -gt $_x_depth ]] || break
					else
						_x_len=$((_x_len+_x_sll))
					fi

					((++_x_i))

					[[ $_x_i -ge $_x_l ]] && ((_x_i--)) && break
				done
			fi

			_x_sls_x+=(-$_x_depth)

			if "$_x_fct":__ _ -; then
				_x_elems=("${_x_vals[@]:_x_pos:_x_len}")
			else
				_x_in__=("${_x_vals[@]:_x_pos:_x_len}")
				_x_elems=(_x_in__)
			fi

			_x_size=${#_x_vals_x[@]}

			[[ $_x_sld ]] && _x_sls_x+=(-$_x_sld)

			for _x_val in "${_x_elems[@]}"; do
				[[ $_x_funcname ]] || CALLER_FUNCNAME_=$_x_fct

				_x_err=

				"$_x_fct": _x_out__ "$_x_val" "${_x_args[@]}" || _x_err=$?

				[[ $_x_funcname ]] || unset -v CALLER_FUNCNAME_

				[[ $_x_err && $_x_errexit ]] && return $_x_err

				_x_vals_x+=("${_x_out__[@]}") _x_out__=()

				[[ $_x_sld ]] && _x_sls_x+=($((${#_x_vals_x[@]}-_x_size))) && _x_size=${#_x_vals_x[@]}
			done

			[[ $_x_sld ]] || _x_sls_x+=($((${#_x_vals_x[@]}-_x_size)))

			_x_pos=$((_x_pos+_x_len))
		done

		_x_sls=("${_x_sls_x[@]}") _x_sls_x=()
		_x_vals=("${_x_vals_x[@]}") _x_vals_x=()

		if [[ $_x_sld ]]; then
			_x_depth=$_x_sld
		elif "$_x_fct":__ - @; then
			((_x_depth--))
		fi
	done

	if [[ ${#_x_vals[@]} -ne 1 ]]; then
		eval $_x_var='("${_x_vals[@]}")'
	else
		eval _x_len='${#'$_x_var'[@]}'

		if [[ $_x_len -gt 1 ]]; then
			eval $_x_var='("$_x_vals")'
		else
			eval $_x_var=\$_x_vals
		fi
	fi
}

input () {
	errorf
}

output () {
	local IFS=$'\n'

	echo "$*"
}

defer () {
	[[ $# -ge 1 ]] || errorf || return

	declare -g -a __defer_p __defer_s __defer_c

	__defer_p+=($BASHPID)
	__defer_s+=(${#@})
	__defer_c+=("$@")

	trap __defer_ EXIT
}


__defer_ () {
	_trace && trace "Defer begin: main"

	local err len
	while [[ ${#__defer_s[@]} -gt 0 ]]; do
		[[ ${__defer_p[-1]} == $BASHPID ]] || break

		_trace && trace "Running defer #${#__defer_s[@]}"

		err= len=${__defer_s[-1]}

		run "${__defer_c[@]: -len}" || err=$?

		[[ $err ]] && _trace && trace "Error defer #${#__defer_s[@]}: $err"

		__defer_c=("${__defer_c[@]:0:${#__defer_c[@]}-len}")
		unset -v __defer_s'[-1]' __defer_p'[-1]'
	done

	_trace && trace "Defer end: main"

	return 0
}

_var () {
	__v "$@"
}

# assign

= () {
	{}= "$@" && return || [[ $? -eq 3 ]] || return 2

	case ${!1@a} in
	*a*)
		local _x_v=$1; shift; eval $_x_v='("$@")' ;;
	*A*)
		local _x_v=$1; shift; eval $_x_v='()'; while [[ $# -gt 0 ]]; do eval $_x_v'[$1]'='$2'; shift 2; done ;;
	*)
		local -n _x_v=$1; _x_v=$2 ;;
	esac
}

=: () {
	{}=: "$@" && return || [[ $? -eq 3 ]] || return 2

	local _x_v=$1 _x_a=${!1@a} _x_v2=$2 _x_a2=${!2@a}; shift 2

	if [[ $# -gt 0 ]]; then
		__f "$@" || return

		local _x_f _x_k _x_ks=() _x_vt _x_vt_i _x_vt_s1_ _x_vt_s2_; local -A _x_vt_a1_ _x_vt_a2_

		while [[ $# -gt 0 ]]; do
			[[ $_x_vt_i != 1 ]] && _x_vt_i=1 || _x_vt_i=2

			if __s $_x_v2 _x_a2 && [[ $_x_a2 == *[aA]* ]] && { _x_f=$1\|; eval _x_a2='${'$_x_v2'[$_x_f]}'; [[ $_x_a2 == *[aA]* ]]; }; then
				_x_vt=_x_vt_a${_x_vt_i}_

				{} $_x_vt:"$_x_a2"

				eval _x_ks='("${!'$_x_v2'[@]}")'

				for _x_k in "${_x_ks[@]}"; do
					[[ $_x_k == "$_x_f"?* ]] || continue

					eval $_x_vt'[${_x_k:${#_x_f}}]'='${'$_x_v2'[$_x_k]}'
				done
			else
				_x_vt=_x_vt_s${_x_vt_i}_

				eval $_x_vt='${'$_x_v2'[$1]}'
			fi

			_x_v2=$_x_vt; shift
		done

		_x_a2=${!_x_v2@a}
	fi

	[[ $_x_v == $_x_v2 ]] && return

	case $_x_a in
	*a*)
		if [[ $_x_a2 == *A* ]]; then
			local _x_k _x_ks=()

			if __s $_x_v2 _x_vt; then
				eval $_x_v='()'; {}=^# _x_ks $_x_v2
			else
				eval $_x_v='()' _x_ks='("${!'$_x_v2'[@]}")'
			fi

			if [[ $_x_a2 == *A* ]]; then
				for _x_k in "${_x_ks[@]}"; do
					eval $_x_v+='("$_x_k" "${'$_x_v2'[$_x_k]}")'
				done
			else
				for _x_k in "${_x_ks[@]}"; do
					eval $_x_v'[$_x_k]'='${'$_x_v2'[$_x_k]}'
				done
			fi
		else
			eval $_x_v='("${'"$_x_v2"'[@]}")'
		fi
		;;
	*A*)
		case $_x_a2 in
		*A*)
			if __s $_x_v2 _x_a2; then
				local _x_k _x_ks=()

				eval $_x_v='()'; {}=^# _x_ks $_x_v2

				if [[ $_x_a2 == *a* ]]; then
					for _x_k in "${_x_ks[@]}"; do
						(((_x_k+=0)%2)) && continue
						eval $_x_v'[${'$_x_v2'[_x_k]}]'='${'$_x_v2'[_x_k+1]}'
					done
				else
					for _x_k in "${_x_ks[@]}"; do
						eval $_x_v'[$_x_k]'='${'$_x_v2'[$_x_k]}'
					done
				fi
			else
				local _x_d; eval _x_d='${'$_x_v2'[@]@A}'

				eval $_x_v="${_x_d#*=}"
			fi
			;;
		*a*)
			local _x_i _x_l

			eval $_x_v='()' _x_l='("${#'$_x_v2'[@]}")'

			for ((_x_i=0; _x_i<_x_l; _x_i+=2)); do
				eval $_x_v'[${'$_x_v2'[_x_i]}]'='${'$_x_v2'[_x_i+1]}'
			done
			;;
		*)
			eval $_x_v='([0]=$'$_x_v2')' ;;
		esac
		;;
	*)
		local -n _x_r=$_x_v; _x_r=${!_x_v2} ;;
	esac
}

# member set

=# () {
	{}=# "$@" && return || [[ $? -eq 3 ]] || return 2

	errorf
}

=#: () {
	errorf
}

=#= () {
	{}=#= "$@" && return || [[ $? -eq 3 ]] || return 2;	errorf
}

+=# () {
	errorf
}

+=#: () {
	errorf
}

# keys count

=## () {
	errorf
}

# keys get

=^# () {
	errorf
}

# values get

=,# () {
	errorf
}

# method call

=@# () {
	{}=@# "$@" && return || [[ $? -eq 3 ]] || return 2;	errorf
}

# append

+= () {
	errorf
}

+=: () {
	errorf
}

~# () {
	{}~# "$@" && return || [[ $? -eq 3 ]] || return 2

	local _x_v=$1'[$1]'; shift

	until [[ $# -eq 0 ]]; do unset -v "$_x_v"; shift; done
}

~= () {
	__v "$@" || return

	unset -v "$@"
}

## struct

# constructor

{} () {
	[[ $# -ge 1 ]] || errorf || return

	local _x_v=${1%%:*} _x_a; _x_a=${1:${#_x_v}+1}; shift

	__v "$_x_v" || return

	[[ ${!_x_v@a} == *A* ]] || errorf "Variable not associative array" || return

	if [[ ! $_x_a ]]; then
		_x_a=A
	elif [[ ${#_x_a} -gt 1 ]]; then
		local _x_i _x_c _x_ta=${_x_a:0:1}

		for ((_x_i=1; _x_i<${#_x_a}; _x_i++)); do
			_x_c=${_x_a:_x_i:1}
			[[ ${_x_ta,,} == *"${_x_c,}"* ]] && continue
			_x_ta+=$_x_c
		done

		_x_a=$_x_ta
	fi

	eval $_x_v='([|]=$_x_a)'

	[[ $# -eq 0 ]] || {}= $_x_v "$@"
}

{}= () {
	[[ $# -ge 1 ]] || errorf || return

	__v "$1" || return

	local _x_v=$1 _x_a; __s $1 _x_a || return; shift

	errorf
}

{}=: () {
	[[ $# -ge 2 ]] || errorf || return

	__v "$1" "$2" || return

	local _x_v=$1 _x_a; __s $1 _x_a || return

	errorf
}

{}=# () {
	[[ $# -ge 2 ]] || errorf || return

	__v "$1" "$3" && __f "$2" || return

	local _x_v=$1 _x_a; __s $1 _x_a || return

	errorf
}

{}=#= () {
	[[ $# -eq 3 ]] || errorf || return

	__v "$1" && __f "$2" || return

	local _x_v=$1 _x_fa=$2'|' _x_a _x_i _x_c _x_ta; __s $1 _x_a || return

	eval _x_a='${'$_x_v'[$_x_fa]}'

	for ((_x_i=0; _x_i<${#3}; _x_i++)); do
		_x_c=${3:_x_i:1}
		[[ ${_x_a,,} == *"${_x_c,}"* ]] && continue
		_x_ta+=$_x_c
	done

	[[ ! $_x_ta ]] && return

	eval $_x_v'[$_x_fa]'+='$_x_ta'
}

{}=## () {
	[[ $# -eq 2 ]] || errorf || return

	__v "$@" || return

	local _x_v=$2 _x_a; __s $2 _x_a || return

	errorf
}

{}=^# () {
	[[ $# -eq 2 ]] || errorf || return

	__v "$@" || return

	local _x_v=$2 _x_a; __s $2 _x_a || return

	# always return (0) for a scalar
	errorf
}

{}=,# () {
	[[ $# -eq 2 ]] || errorf || return

	__v "$@" || return

	local _x_v=$2 _x_a; __s $2 _x_a || return

	errorf
}

{}=@# () {
	[[ $# -ge 3 ]] || errorf || return

	__v "$1" "$2" && __f "$3" || return

	local _x_v=$2 _x_a; __s $2 _x_a || return

	[[ $_x_a == *@* ]] || errorf "Member not callable" || return

	errorf
}

{}~# () {
	[[ $# -ge 2 ]] || errorf || return

	__v "$1" || return

	local _x_v=$1 _x_a; __s $1 _x_a || return; shift

	errorf
}

__s () {
	[[ ${!1@a} == *A* ]] && eval $2='${'$1'[|]}' &&	[[ ${!2} ]] || return 3
}

__f () {
	while [[ $# -gt 0 ]]; do
		valid_field "$1" || errorf "Illegal name '$1' for field" || return; shift
	done
}

__v () {
	while [[ $# -gt 0 ]]; do
		if ! is_declared "$1"; then
			[[ $1 ]] || errorf "Missing variable name" || return

			valid_name "$1" || errorf "Illegal name '$1' for variable" || return

			errorf "Variable '$1' not declared" || return
		fi

		[[ $1 != _x_* || $1 == *_ ]] || errorf "Conflicting name '$1' for variable" || return

		shift
	done
}

__caller () {
	local source depth len=${#FUNCNAME[@]}

	for ((depth=2; depth<len; depth++)); do
		source=${BASH_SOURCE[depth]}

		[[ $source != "$__functions" ]] && break
	done

	[[ $depth -lt $len ]] || source=$0

	[[ $CALLER_SOURCE_ ]] && CALLER_SOURCE=$CALLER_SOURCE_ || \
		CALLER_SOURCE=$source

	[[ $CALLER_LINENO_ ]] && CALLER_LINENO=$CALLER_LINENO_ || \
		CALLER_LINENO=${BASH_LINENO[depth-1]}

	[[ $CALLER_FUNCNAME_ ]] && CALLER_FUNCNAME=$CALLER_FUNCNAME_ || \
		CALLER_FUNCNAME=${FUNCNAME[depth-1]}
}

__caller_ () {
	unset -v CALLER_SOURCE CALLER_LINENO CALLER_FUNCNAME
}

__functions () {
	local args fct name proto out_ini out_val in_ini in_set in_val

	while read -r -a args; do
		fct=${args[-1]}

		[[ $fct =~ ^([^\]\[]*[^:]):\[(.*)\]$ ]] || continue

		name=${BASH_REMATCH[1]} proto=${BASH_REMATCH[2]}

		case ${proto:0:1} in
		-)
			out_ini=
			out_val=\$_x_var_
			;;
		@)
			out_ini='()'
			out_val=\${_x_var_[*]}
			;;
		*)
			_debug && warn "Invalid function prototype output argument: $fct"
			continue
			;;
		esac
		case ${proto:1:1} in
		-)
			in_ini=
			in_set='\$$_x_var_'
			in_val=\$_x_val_
			;;
		@)
			in_ini='()'
			in_set=\''("${'\'\$_x_var_\''[@]}")'\'
			in_val=_x_val_
			;;
		*)
			_debug && warn "Invalid function prototype input argument: $fct" ;;
		esac

		_debug && [[ ${#proto} -gt 2 ]] && warn "Invalid function prototype arguments: $fct"

		eval '
			'"$name"':__ () {
				local i arg type proto='"$proto"'

				for arg; do
					[[ $proto ]] || return 1

					type=${proto:0:1} proto=${proto:1}

					for ((i=0; i<${#arg}; i++)); do
						[[ ${arg:i:1} == [_$type] ]] && continue 2
					done

					return 1
				done

				return 0
			}

			'"$name"': () {
				'"'$fct'"' "$@"
			}

			'"$name"':: () {
				[[ $# -gt 0 ]] || errorf || return

				_var "$1" || return

				local _x_var_=$1 _x_val_='"$in_ini"'; shift

				eval _x_val_='"$in_set"'

				'"'$fct'"' $_x_var_ "'"$in_val"'" "$@"
			}

			'"$name"' () {
				local _x_var_='"$out_ini"'

				'"'$fct'"' _x_var_ "$@"

				local IFS=$'\''\n'\''

				echo "'"$out_val"'"
			}
		'
	done < <(
		declare -F
	)
}

__functions && readonly __functions__=_
