#!/usr/bin/env bash

[[ $__functions__ ]] && return

shopt -qo posix && return 126

__functions=$BASH_SOURCE

declare -r  LOG_LEVEL_NONE=_
declare -ri LOG_LEVEL_ERROR=0
declare -ri LOG_LEVEL_WARNING=1
declare -ri LOG_LEVEL_NOTE=2
declare -ri LOG_LEVEL_INFO=3
declare -ri LOG_LEVEL_DEBUG=4
declare -ri LOG_LEVEL_TRACE=5

declare -x LOG_{LEVEL,PREFIX,DATE,DATE_FORMAT,SOURCE,JSON,FILE}

_error () { log -$LOG_LEVEL_ERROR; }
_warn  () { log -$LOG_LEVEL_WARNING; }
_note  () { log -$LOG_LEVEL_NOTE; }
_msg   () { log -$LOG_LEVEL_INFO; }
_debug () { log -$LOG_LEVEL_DEBUG; }
_trace () { log -$LOG_LEVEL_TRACE; }

error () { log $LOG_LEVEL_ERROR "$@"; exit 1; }
warn  () { log $LOG_LEVEL_WARNING "$@"; }
note  () { log $LOG_LEVEL_NOTE "$@"; }
msg   () { log $LOG_LEVEL_INFO "$@"; }
debug () { log $LOG_LEVEL_DEBUG "$@"; }
trace () { log $LOG_LEVEL_TRACE "$@"; }

errorf () {
	[[ $# -gt 0 ]] || set "Invalid arguments"

	_caller

	! ( error "{$CALLER_SOURCE@$CALLER_LINENO#$CALLER_FUNCNAME}" "$@" )

	_caller_

	return 2
}

warnf () {
	[[ $# -gt 0 ]] || set "Unexpected arguments"

	_caller

	warn "{$CALLER_SOURCE@$CALLER_LINENO#$CALLER_FUNCNAME}" "$@"

	_caller_
}

is_declared () {
	[[ $# -ge 1 ]] || errorf || return

	if [[ $# -eq 1 ]]; then
		declare -p "$1" &>/dev/null
		return
	fi

	local attrs=$(declare -p "$1" 2>/dev/null)
	shift

	attrs=${attrs#* }
	attrs=${attrs%% *}

	[[ $attrs ]] || return 1

	attrs=${attrs//-}

	local i t_attrs
	for t_attrs; do
		t_attrs=${t_attrs//-}
		for ((i=0; i<${#t_attrs}; i++)); do
			[[ $attrs != *${t_attrs:i:1}* ]] && continue 2
		done
		return 0
	done
	return 3
}

is_string () {
	[[ $# -eq 1 ]] || errorf || return

	if is_declared "$1" i a A; then
		return 3
	elif [[ $? -eq 3 ]]; then
		return 0
	fi
	return 1
}

is_integer () {
	[[ $# -eq 1 ]] || errorf || return

	is_declared "$1" i
}

is_array () {
	[[ $# -eq 1 ]] || errorf || return

	is_declared "$1" a
}

is_hash () {
	[[ $# -eq 1 ]] || errorf || return

	is_declared "$1" A
}

is_function () {
	[[ $# -eq 1 ]] || errorf || return

	declare -F "$1" >/dev/null
}

is_pipeline () {
	[[ $# -eq 1 ]] || errorf || return

	declare -F "$1"{,:,::,:__} >/dev/null
}

is_command () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $(type -P "$1") ]]
}

is_exec () {
	[[ $# -eq 1 ]] || errorf || return

	is_function "$1" || is_command "$1" || [[ $(type -t "$1") == builtin ]]
}

bool () {
	[[ $# -eq 1 ]] || errorf || return

	case $1 in
	1 | \
	true | TRUE | True | t | T | \
	yes | YES | Yes | y | Y | \
	on | ON | On)
	return 0
	;;
	0 | \
	false | FALSE | False | f | F | \
	no | NO | No | n | N | \
	off | OFF | Off)
	return 1
	;;
	esac
	return 3
}


color () {
	[[ $# -eq 1 ]] || errorf || return

	colorc "$1" && echo -n "$COLORC"
}

colorc () {
	[[ $# -eq 1 ]] || errorf || return

	local -A cc=(
		[none]=0
		[black]=30
		[red]=31
		[green]=32
		[yellow]=33
		[blue]=34
		[magenta]=35
		[cyan]=36
		[white]=37
	)
	local -A sc=(
		[+]=1
		[-]=2
		[/]=3
		[=]=4
		[%]=7
	)

	COLORC=

	local i code list elem name fmt num

	list=$1

	while [[ $list ]]; do
		elem=${list%%,*}
		list=${list:${#elem}}

		name=${elem%%[![:word:]]*}
		fmt=${elem:${#name}}

		if [[ $name ]]; then
			num=${cc[$name]}

			if [[ $num ]]; then
				[[ $list ]] && ((num+=10))
				[[ $code ]] && code+=\;
				code+=$num
			else
				code=
				break
			fi
		fi

		for ((i=0; i<${#fmt}; i++)); do
			num=${sc[${fmt:i:1}]}

			if [[ $num ]]; then
				[[ $code ]] && code+=\;
				code+=$num
			else
				code=
				break 2
			fi
		done

		list=${list#,}
	done

	[[ $code ]] || return

	COLORC=$'\e'[${code}m
}

echoc () {
	local nl
	[[ $1 == -n ]] && nl=$1 && shift

	local color base code

	if [[ $ECHOC ]]; then
		bool $ECHOC && color=_
	else
		[[ -t 1 ]] && color=_
	fi

	if [[ $ECHOC_BASE ]] && colorc "$ECHOC_BASE"; then
		base=$COLORC
	fi

	local out space spec

	while [[ $# -gt 0 ]]; do
		spec=${1#@}; spec=${spec#:}; spec=${spec%@}

		if [[ $1 == @* ]] && { [[ ! $spec ]] || colorc "$spec"; }; then
			[[ $spec ]] && code=$COLORC
			[[ $1 == @:* ]] && base=$code
			[[ $1 == *@ ]] && space=_ || space=
		else
			if [[ ! $out ]]; then
				if [[ $color ]]; then
					out+=$'\e'[0m
					[[ $base ]] && out+=$base
				fi
			else
				[[ $space ]] && out+=' '
			fi

			if [[ $code ]]; then
				[[ $color ]] && out+=$code
			fi

			out+=$1

			if [[ $code ]]; then
				if [[ $color ]]; then
					out+=$'\e'[0m
					[[ $base ]] && out+=$base
				fi
				code=
			fi

			space=_
		fi

		shift
	done

	[[ $color ]] && out+=$'\e'[0m

	echo $nl "$out" || :
}

echoe () {
	echoc "$@" >&2 || :
}

log () {
	[[ $# -ge 1 ]] || errorf || return

	local level=$1 test drop && shift

	valid_int "$level" || errorf "Invalid log level" || return

	local levels=(
		error:Error:red
		warning:Warning:yellow
		note:Note:green
		info::cyan
		debug:DEBUG:
		trace:TRACE:
	)

	if [[ $level == -* ]] ; then
		test=_
		level=${level##*-}
	fi

	local level_def=${levels[$level]} log_level=$LOG_LEVEL

	[[ $level_def ]] || errorf "Unknown log level" || return

	if [[ $log_level == $LOG_LEVEL_NONE ]]; then
		drop=_
	else
		valid_uint "$log_level" || log_level=$LOG_LEVEL_INFO

		[[ $log_level -lt $level ]] && drop=_
	fi

	if [[ $test ]]; then
		[[ $drop ]] && return 1
		return 0
	fi
	[[ $drop ]] && return 0

	local -A field; local args=() name value json code header=${level_def%:*} color=${level_def##*:}; code=${header%:*} header=${header#*:}

	bool "$LOG_JSON" && json=_

	if [[ $json ]] || bool "$LOG_DATE" || [[ ! $LOG_DATE && $log_level -ge $LOG_LEVEL_DEBUG ]]; then
		value=
		[[ $LOG_DATE_FORMAT ]] && value=$(date +"$LOG_DATE_FORMAT")
		[[ $value ]] || value=$(date -In)

		field[ts]=$value
	fi

	if bool "$LOG_SOURCE" || [[ ! $LOG_SOURCE && $log_level -ge $LOG_LEVEL_TRACE ]]; then
		field[pid]=$BASHPID

		_caller

		field[source]=$CALLER_SOURCE@$CALLER_LINENO

		_caller_
	fi

	if [[ $json ]]; then
		json={

		value=${field[ts]} && [[ $value ]] && jquote:: value && json+='"ts":'"$value",
		value=${field[pid]} && [[ $value ]] && json+='"pid":"'"$value"'"',
		value=${field[source]} && [[ $value ]] && jquote:: value && json+='"source":'"$value",

		json+='"level":"'$code'"',

		jquote: value "$(echoc "$@")"
		json+='"msg":'"$value"}

		args=("$json")
	else
		if [[ ! $LOG_FILE ]]; then
			local log_prefix_opt log_prefix=$LOG_PREFIX prefix

			if [[ $log_prefix == [+-]* ]]; then
				log_prefix_opt=${log_prefix:0:1}
				log_prefix=${log_prefix#?}
			fi
			if [[ $log_prefix == _ ]]; then
				log_prefix=
			elif [[ ! $log_prefix ]]; then
				log_prefix='>>>'
			fi

			[[ -t 2 && $log_prefix_opt != + ]] || prefix=$log_prefix

			[[ $log_level -ge $LOG_LEVEL_DEBUG && $log_prefix_opt != - ]] && prefix=$log_prefix

			[[ $prefix ]] && args+=("$prefix")
		fi

		value=${field[ts]} && [[ $value ]] && args+=("[$value]")
		value=${field[pid]} && [[ $value ]] && args+=("$value")
		value=${field[source]} && [[ $value ]] && args+=("{$value}")

		[[ $color ]] || color=none

		if [[ $header ]]; then
			local header_color=$color sep_color=$color

			if [[ $color != none ]]; then
				header_color+=+=
				sep_color+=+
			fi

			args+=(@$header_color@ "$header")
			args+=(@$sep_color ':')
		fi

		args+=(@:$color@ "$@")
	fi

	[[ $LOG_FILE ]] && ECHOC=0 echoc "${args[@]}" >> "$LOG_FILE" && return 0

	ECHOC_BASE=none echoe "${args[@]}"
}

ask () {
	local question=$1 && shift || :

	[[ $question ]] || question=?

	local -A answers
	local answer choose reply

	for answer; do
		[[ $answer ]] || continue

		answers[$answer]=_
	done

	[[ $# -gt 0 ]] && choose=" ($(IFS=\|; echo "$*"))"

	while :; do
		echoe -n @yellow+ "$question$choose: "
		read reply

		[[ $# -gt 0 ]] || break
		[[ $reply && ${answers[$reply]} ]] && break
	done

	echo "$reply"
}

confirm () {
	[[ $# -eq 0 ]] || errorf || return

	[[ $(ask "Are you sure you want to continue?" y n) == y ]]
}

valid_name () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 =~ ^[[:alpha:]_][[:alnum:]_]*$ ]]
}

valid_identifier () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 =~ ^[[:alpha:]]([[:alnum:]-]*[[:alnum:]])?$ ]]
}

valid_int () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 =~ ^[-+]?[[:digit:]]+$ ]]
}

valid_uint () {
	[[ $# -eq 1 ]] || errorf || return

	valid_int "$1" && [[ $1 != -* ]]
}

valid_float () {
	[[ $# -eq 1 ]] || errorf || return

	[[ $1 =~ ^[-+]?[[:digit:]]*\.?[[:digit:]]+([eE][[:digit:]]+)?$ ]]
}

valid_ufloat () {
	[[ $# -eq 1 ]] || errorf || return

	valid_float "$1" && [[ $1 != -* ]]
}

valid_bool () {
	[[ $# -eq 1 ]] || errorf || return

	bool "$1" || [[ $? -ne 3 ]]
}

contains () {
	[[ $# -ge 1 ]] || errorf || return

	local val=$1 elem && shift

	for elem; do
		[[ $elem == "$val" ]] && return 0
	done
	return 1
}

selects () {
	[[ $# -ge 1 ]] || errorf || return

	[[ $# -gt 1 ]] || return 0

	contains "$@"
}

concat () {
	[[ $# -ge 1 ]] || errorf || return

	local sep=$1 str set elem && shift

	for elem; do
		[[ $set ]] && str+=$sep || set=_
		str+=$elem
	done

	echo "$str"
}

push () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	local _x_arr=$1 _x_str=$2 _x_delim=$3 && _var "$1" || return

	! _debug || is_array "$_x_arr" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	[[ $# -ge 3 ]] || _x_delim=,

	local _x_out=() _x_slen=${#_x_str} _x_dlen=${#_x_delim} _x_pos=0 _x_cur=

	eval _x_out='("${'$_x_arr'[@]}")'

	while [[ $_x_pos -lt $_x_slen ]]; do
		if [[ $_x_dlen -eq 0 ]]; then
			_x_out+=("${_x_str:_x_pos++:1}")
		elif [[ ${_x_str:_x_pos:_x_dlen} == "$_x_delim" ]]; then
			_x_out+=("$_x_cur")
			_x_cur=
			((_x_pos+=_x_dlen))
		else
			_x_cur+=${_x_str:_x_pos++:1}
		fi
	done

	[[ $_x_cur ]] && _x_out+=("$_x_cur")

	eval $_x_arr='("${_x_out[@]}")'
}

len:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	eval $1=${#2}
}

count:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	eval $1=\${#$2[@]}
}

index:[-@] () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_key=$3 && [[ $3 ]] || _x_key=0

	eval $1=\${$2[\$_x_key]}
}

total:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_total=0 _x_val _x_vals=()

	eval _x_vals='("${'$2'[@]}")' && [[ ${#_x_vals[@]} -gt 0 ]] || errorf "Array is empty" || return

	for _x_val in "${_x_vals[@]}"; do
		_x_total=$((_x_total+_x_val))
	done

	eval $1=\$_x_total
}

min:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_min _x_val _x_vals=()

	eval _x_vals='("${'$2'[@]}")' && [[ ${#_x_vals[@]} -gt 0 ]] || errorf "Array is empty" || return

	for _x_val in "${_x_vals[@]}"; do
		[[ ! $_x_min || $_x_val -lt $_x_min ]] && _x_min=$_x_val
	done

	eval $1=\$_x_min
}

max:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_max _x_val _x_vals=()

	eval _x_vals='("${'$2'[@]}")' && [[ ${#_x_vals[@]} -gt 0 ]] || errorf "Array is empty" || return

	for _x_val in "${_x_vals[@]}"; do
		[[ ! $_x_max || $_x_val -gt $_x_max ]] && _x_max=$_x_val
	done

	eval $1=\$_x_max
}

avg:[-@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_avg=0 _x_val _x_vals=()

	eval _x_vals='("${'$2'[@]}")' && [[ ${#_x_vals[@]} -gt 0 ]] || errorf "Array is empty" || return

	for _x_val in "${_x_vals[@]}"; do
		_x_avg=$((_x_avg+_x_val))
	done

	_x_avg=$((_x_avg/${#_x_vals[@]}))

	eval $1=\$_x_avg
}

quote:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_str="'${2//\'/\'\\\'\'}'"

	eval $1=\$_x_str
}

jquote:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_str=${2//\\/\\\\} && _var "$1" || return

	_x_str="\"${_x_str//\"/\\\"}\""

	eval $1=\$_x_str
}

pad:[--] () {
	[[ $# -ge 3 && $# -le 4 ]] || errorf || return

	local _x_str=$2 _x_len=$3 _x_pad=$4 && _var "$1" || return

	valid_uint "$_x_len" || errorf "Invalid pad length" || return

	[[ $_x_pad ]] || _x_pad=' '

	local _x_pad_c _x_pad_len=${#_x_pad} _x_add_len=$((_x_len-${#_x_str}))

	if [[ $_x_add_len -gt 0 ]]; then
		for ((_x_pad_c=$((_x_add_len/_x_pad_len)); _x_pad_c>0; _x_pad_c--)); do
			_x_str+=$_x_pad
		done
		_x_add_len=$((_x_len-${#_x_str})) && [[ $_x_add_len -gt 0 ]] && _x_str+=${_x_pad:0:_x_add_len}
	fi

	eval $1=\$_x_str
}

trim:[--] () {
	_trim _ "$@"
}

triml:[--] () {
	_trim - "$@"
}

trimr:[--] () {
	_trim + "$@"
}

_trim () {
	[[ $# -ge 3 && $# -le 4 ]] || errorf || return

	local _x_side=$1 _x_var=$2 _x_str=$3 _x_chars=$4 && _var "$2" || return

	[[ $# -gt 3 ]] || _x_chars=$' \t\n'

	if [[ $_x_chars ]]; then
		local _x_i _x_len

		if [[ $_x_side == - || $_x_side == _ ]]; then
			_x_len=${#_x_str}
			for ((_x_i=0; _x_i<_x_len; _x_i++)); do
				[[ $_x_chars == *"${_x_str:_x_i:1}"* ]] || break
			done
			_x_str=${_x_str:_x_i}
		fi

		if [[ $_x_side == + || $_x_side == _ ]]; then
			_x_len=${#_x_str}
			for ((_x_i=_x_len; _x_i>0; _x_i--)); do
				[[ $_x_chars == *"${_x_str:_x_i-1:1}"* ]] || break
			done
			_x_str=${_x_str:0:_x_i}
		fi
	fi

	eval $_x_var=\$_x_str
}

upper:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_str=${2^^}

	eval $1=\$_x_str
}

lower:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_str=${2,,}

	eval $1=\$_x_str
}

upperf:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_str=${2^}

	eval $1=\$_x_str
}

lowerf:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" || return

	local _x_str=${2,}

	eval $1=\$_x_str
}

file_dir:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_file=$2 _x_root && _var "$1" || return

	while [[ $_x_file == */ ]]; do
		_x_file=${_x_file:0:-1}
	done
	while [[ $_x_file == *[!/] ]]; do
		_x_file=${_x_file:0:-1}
	done
	while [[ $_x_file == */ ]]; do
		_x_file=${_x_file:0:-1}
	done

	if [[ ! $_x_file ]]; then
		_x_root=${1%%[!/]*}

		[[ $_x_root && $_x_root != // ]] && _x_root=/

		_x_file=$_x_root
	fi

	[[ $_x_file ]] || _x_file=.

	eval $1=\$_x_file
}

file_name:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_file=$2 _x_root && _var "$1" || return

	while [[ $_x_file == */ ]]; do
		_x_file=${_x_file:0:-1}
	done

	_x_file=${_x_file##*/}

	if [[ ! $_x_file ]]; then
		_x_root=${1%%[!/]*}

		[[ $_x_root && $_x_root != // ]] && _x_root=/

		_x_file=$_x_root
	fi

	eval $1=\$_x_file
}

file_base:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_file_=$2 && _var "$1" || return

	file_name: _x_file_ "$_x_file_"

	_x_file_=${_x_file_%.*}

	eval $1=\$_x_file_
}

file_ext:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_file_=$2 && _var "$1" || return

	file_name: _x_file_ "$_x_file_"

	_x_file_=${_x_file_##*.}

	eval $1=\$_x_file_
}

duration:[--] () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_duration=$2 && _var "$1" || return

	local -A _x_units=(
		[s]=1
		[m]=60
		[h]=3600
	)

	local -i _x_seconds=0

	local _x_num _x_unit _x_factor

	while [[ $_x_duration ]]; do
		_x_num=${_x_duration%%[!0-9]*}

		[[ $_x_num ]] || return 1

		_x_duration=${_x_duration:${#_x_num}}
		_x_unit=${_x_duration%%[[:digit:]]*}

		[[ $_x_unit ]] || _x_unit=s

		_x_duration=${_x_duration:${#_x_unit}}
		_x_factor=${_x_units[$_x_unit]}

		[[ $_x_factor ]] || return 1

		_x_seconds=$((_x_seconds+_x_num*_x_factor))
	done

	eval $1=$_x_seconds
}

filter:[@@] () {
	[[ $# -ge 4 ]] || errorf || return

	local _x_var=$1 _x_arr=$2 _x_op=$3 _x_type=_ _x_filter=$4 && _var "$1" && _var "$2" && shift 4 || return

	if _debug; then
		is_array "$_x_var" || [[ $? -eq 1 ]] || warnf "Output variable is not an array"
		is_array "$_x_arr" || warnf "Variable is not an array"
	fi

	if [[ ${#_x_op} -gt 1 ]]; then
		_x_type=${_x_op:1}
		_x_op=${_x_op:0:1}

		[[ $_x_type == [_=~@] ]] || errorf "Invalid filter operator" || return

		if [[ $_x_type == @ ]]; then
			! _debug || is_exec "$_x_filter" || warnf "Filter command not defined"
		else
			[[ $# -eq 0 ]] || errorf || return
		fi
	fi

	[[ $_x_op == [-+] ]] || errorf "Invalid filter operator" || return

	local _x_out=() _x_match _x_found _x_arg _x_args=() _x_elems=() _x_elem

	eval _x_elems='("${'$_x_arr'[@]}")'

	for _x_elem in "${_x_elems[@]}"; do
		_x_match=

		case $_x_type in
		'_')
			if [[ $_x_elem == "$_x_filter" ]]; then
				_x_match=_
			fi
			;;
		'=')
			if [[ $_x_elem == $_x_filter ]]; then
				_x_match=_
			fi
			;;
		'~')
			if [[ $_x_elem =~ $_x_filter ]]; then
				_x_match=_
			else
				[[ $? -eq 1 ]] || errorf "Invalid filter regular expression" || return
			fi
			;;
		'@')
			_x_args=()
			_x_found=

			for _x_arg; do
				if [[ $_x_arg == *{}* ]]; then
					_x_arg=${_x_arg//\{\}/"$_x_elem"}
					_x_found=_
				fi
				_x_args+=("$_x_arg")
			done
			[[ $_x_found ]] || _x_args+=("$_x_elem")

			if $_x_filter "${_x_args[@]}" >/dev/null; then
				_x_match=_
			fi
			;;
		esac

		if [[ $_x_match ]]; then
			[[ $_x_op == - ]] && continue
		else
			[[ $_x_op == + ]] && continue
		fi

		_x_out+=("$_x_elem")
	done

	eval $_x_var='("${_x_out[@]}")'
}

map:[@@] () {
	[[ $# -ge 3 ]] || errorf || return

	local _x_var=$1 _x_arr=$2 _x_exec=$3 && _var "$1" && _var "$2" && shift 3 || return

	if _debug; then
		is_array "$_x_var" || [[ $? -eq 1 ]] || warnf "Output variable is not an array"
		is_array "$_x_arr" || warnf "Variable is not an array"
		is_exec "$_x_exec" || warnf "Map command not defined"
	fi

	local _x_out=() _x_found _x_pipe _x_arg _x_args=() _x_elems=() _x_elem_

	eval _x_elems='("${'$_x_arr'[@]}")'

	is_pipeline "$_x_exec" && _x_pipe=_

	for _x_elem_ in "${_x_elems[@]}"; do
		_x_args=()
		_x_found=

		for _x_arg; do
			if [[ $_x_arg == *{}* ]]; then
				_x_arg=${_x_arg//\{\}/"$_x_elem_"}
				_x_found=_
			fi
			_x_args+=("$_x_arg")
		done

		if [[ ! $_x_found ]]; then
			if [[ $_x_pipe ]]; then
				_x_args=("$_x_elem_" "${_x_args[@]}")
			else
				_x_args+=("$_x_elem_")
			fi
		fi

		if [[ $_x_pipe ]]; then
			${_x_exec}: _x_elem_ "${_x_args[@]}"
		else
			_x_elem_=$($_x_exec "${_x_args[@]}") || return $?
		fi

		_x_out+=("$_x_elem_")
	done

	eval $_x_var='("${_x_out[@]}")'
}

sep:[@-] () {
	[[ $# -ge 2 && $# -le 5 ]] || errorf || return

	local _x_str=$2 _x_regex=$3 _x_limit=0 _x_keep= && _var "$1" || return

	! _debug || is_array "$1" || [[ $? -eq 1 ]] || warnf "Output variable is not an array"

	[[ $# -lt 3 ]] && _x_regex=\\s+

	if [[ $# -ge 4 ]]; then
		_x_limit=$4

		valid_uint "$_x_limit" || errorf "Invalid limit number" || return
	fi
	if [[ $# -ge 5 ]]; then
		if bool "$5"; then
			_x_keep=_
		elif [[ $? -ne 1 ]]; then
			errorf "Invalid boolean for keep" || return
		fi
	fi

	local _x_out=() _x_count=0 _x_sep _x_rem _x_len

	while :; do
		((++_x_count))

		if [[ $_x_limit -eq 0 || $_x_count -lt $_x_limit ]] && [[ $_x_str =~ ($_x_regex).* ]]; then
			_x_sep=${BASH_REMATCH[1]}
			_x_rem=${BASH_REMATCH[0]}

			[[ $_x_sep ]] || _x_rem=${_x_rem:1}

			_x_len=$((${#_x_str}-${#_x_rem}))

			_x_out+=("${_x_str:0:_x_len}")
			[[ $_x_keep ]] && _x_out+=("$_x_sep")

			_x_str=${_x_str:_x_len+${#_x_sep}}
		else
			[[ $? -eq 1 ]] || errorf "Invalid separator regular expression" || return

			_x_out+=("$_x_str")
			_x_str=
		fi

		[[ $_x_str ]] || break
	done

	eval $1='("${_x_out[@]}")'
}

tie:[-@] () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	local _x_sep=$3 && _var "$1" || return

	! _debug || is_array "$2" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	local _x_out _x_set _x_elems=() _x_elem

	eval _x_elems='("${'$2'[@]}")'

	for _x_elem in "${_x_elems[@]}"; do
		[[ $_x_set ]] && _x_out+=$_x_sep || _x_set=_
		_x_out+=$_x_elem
	done

	eval $1=\$_x_out
}

reverse:[@@] () {
	[[ $# -eq 2 ]] || errorf || return

	_var "$1" && _var "$2" || return

	if _debug; then
		is_array "$1" || [[ $? -eq 1 ]] || warnf "Output variable is not an array"
		is_array "$2" || warnf "Variable is not an array"
	fi

	local _x_i _x_tmp _x_out=()

	eval _x_out='("${'$2'[@]}")'

	_x_i=$((${#_x_out[@]}/2))

	while [[ $_x_i -gt 0 ]]; do
		_x_tmp=${_x_out[-_x_i]}
		_x_out[-_x_i]=${_x_out[_x_i-1]}
		_x_out[--_x_i]=$_x_tmp
	done

	eval $1='("${_x_out[@]}")'
}

map:new () {
	[[ $# -ge 1 ]] || errorf || return

	local _x_var=$1 _x_field _x_len && _var "$1" && shift || return

	if is_declared $_x_var; then
		! _debug || is_hash "$_x_var" || warnf "Map variable is not an associative array"
	else
		declare -g -A $_x_var
	fi

	eval _x_len=\${#$_x_var[@]} && [[ $_x_len -eq 0 ]] || errorf "Map variable must be empty" || return

	if [[ $# -eq 0 ]]; then
		set -- -
	else
		for _x_field; do
			valid_name "$_x_field" || errorf "Illegal field name" || return
		done
	fi

	IFS=' ' eval $_x_var[:]='"$*"'
}

map:get () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	local _x_var=$1 _x_key=$2 _x_target=$1 && _var "$1" || return

	! _debug || is_hash "$_x_var" || warnf "Map variable is not an associative array"

	[[ $_x_key ]] || errorf "Illegal empty key" || return

	if [[ $# -ge 3 ]]; then
		_var "$3" || return

		_x_target=$3

		! _debug || is_hash "$_x_target" || warnf "Target variable is not an associative array"
	fi

	local _x_fields _x_field _x_len _x_sets

	eval _x_fields=\${$_x_var[:]}

	[[ $_x_fields ]] || errorf "Map variable invalid" || return

	if [[ $_x_fields == - ]]; then
		eval _x_len=\${$_x_var[\$_x_key:]}

		_x_sets=()

		if [[ $_x_len ]]; then
			for ((_x_field=0; _x_field<_x_len; _x_field++)); do
				_x_sets+=($_x_target[$_x_field]=\${$_x_var[\$_x_key:$_x_field]})
			done
		else
			_x_len=0
		fi

		eval _x_fields='("${!'$_x_target'[@]}")' "${_x_sets[@]}"

		_x_sets=()

		for _x_field in "${_x_fields[@]}"; do
			[[ $_x_field == *[![:digit:]]* ]] && continue

			_x_field=$((_x_field+0))

			[[ $_x_field -gt $_x_len ]] || continue

			_x_sets+=($_x_target[$_x_field])
		done

		if [[ ${#_x_sets[@]} -gt 0 ]]; then
			eval unset -v "${_x_sets[@]}"
		fi
	else
		_x_sets=()

		for _x_field in $_x_fields; do
			_x_sets+=($_x_target[$_x_field]=\${$_x_var[\$_x_key:$_x_field]})
		done

		eval "${_x_sets[@]}"
	fi
}

map:pop () {
	map:get "$@"
	map:del $1 "$2"
}

map:set () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	local _x_var=$1 _x_key=$2 _x_target=$1 && _var "$1" || return

	! _debug || is_hash "$_x_var" || warnf "Map variable is not an associative array"

	[[ $_x_key ]] || errorf "Illegal empty key" || return

	if [[ $# -ge 3 ]]; then
		_var "$3" || return

		_x_target=$3

		! _debug || is_hash "$_x_target" || warnf "Target variable is not an associative array"
	fi

	local _x_fields _x_field _x_sets _x_len=_

	eval _x_fields=\${$_x_var[:]}

	[[ $_x_fields ]] || errorf "Map variable invalid" || return

	if [[ $_x_fields == - ]]; then
		_x_len=-1

		eval _x_fields='("${!'$_x_target'[@]}")'

		_x_sets=()

		for _x_field in "${_x_fields[@]}"; do
			[[ $_x_field == *[![:digit:]]* ]] && continue

			_x_field=$((_x_field+0))

			_x_sets+=($_x_var[\$_x_key:$_x_field]=\${$_x_target[$_x_field]})

			[[ $_x_field -gt $_x_len ]] && _x_len=$_x_field
		done

		_x_len=$((_x_len+1))

		if [[ ${#_x_sets[@]} -gt 0 ]]; then
			eval "${_x_sets[@]}"
		fi

		eval _x_fields=\${$_x_var[\$_x_key:]}

		if [[ $_x_fields ]]; then
			_x_sets=()

			for ((_x_field=$((_x_fields-1)); _x_field>=_x_len; _x_field--)); do
				_x_sets+=($_x_var[\$_x_key:$_x_field])
			done

			if [[ ${#_x_sets[@]} -gt 0 ]]; then
				eval unset -v "${_x_sets[@]}"
			fi
		fi
	else
		_x_sets=()

		for _x_field in $_x_fields; do
			_x_sets+=($_x_var[\$_x_key:$_x_field]=\${$_x_target[$_x_field]})
		done

		eval "${_x_sets[@]}"
	fi

	eval $_x_var[\$_x_key:]=$_x_len
}

map:push () {
	map:set "$@"
	map:clear $1 "${@:3}"
}

map:del () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_var=$1 _x_key=$2 && _var "$1" || return

	! _debug || is_hash "$_x_var" || warnf "Map variable is not an associative array"

	[[ $_x_key ]] || errorf "Illegal empty key" || return

	local _x_fkey _x_fkeys=()

	eval _x_fkeys='("${!'$_x_var'[@]}")'

	for _x_fkey in "${_x_fkeys[@]}"; do
		[[ $_x_fkey == *:* ]] || continue
		[[ ${_x_fkey%:*} == "$_x_key" ]] || continue

		eval unset -v $_x_var[\$_x_fkey]
	done
}

map:clear () {
	[[ $# -ge 1 && $# -le 2 ]] || errorf || return

	local _x_var=$1 _x_target=$1 && _var "$1" || return

	! _debug || is_hash "$_x_var" || warnf "Map variable is not an associative array"

	if [[ $# -ge 2 ]]; then
		_x_target=$2 && _var "$2" || return

		! _debug || is_hash "$_x_target" || warnf "Target variable is not an associative array"
	fi

	local _x_fields _x_field _x_sets

	eval _x_fields=\${$_x_var[:]}

	[[ $_x_fields ]] || errorf "Map variable invalid" || return

	if [[ $_x_fields == - ]]; then
		eval _x_fields='("${!'$_x_target'[@]}")'

		_x_sets=()

		for _x_field in "${_x_fields[@]}"; do
			[[ $_x_field == *[![:digit:]]* ]] && continue

			_x_sets+=($_x_target[$_x_field])
		done

		if [[ ${#_x_sets[@]} -gt 0 ]]; then
			eval "${_x_sets[@]}"
		fi
	else
		_x_sets=()

		for _x_field in $_x_fields; do
			_x_sets+=($_x_target[$_x_field])
		done

		eval unset -v "${_x_sets[@]}"
	fi
}

map:key () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_var=$1 _x_key=$2 _x_found && _var "$1" || return

	! _debug || is_hash "$_x_var" || warnf "Map variable is not an associative array"

	[[ $_x_key ]] || errorf "Illegal empty key" || return

	eval _x_found=\${$_x_var[\$_x_key:]}

	[[ $_x_found ]]
}

map:keys () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_var=$1 _x_target=$2 && _var "$1" && _var "$2" || return

	if _debug; then
		is_hash "$_x_var" || warnf "Map variable is not an associative array"
		is_array "$_x_target" || warnf "Target variable is not an array"
	fi

	local _x_fkey _x_fkeys=() _x_keys=()

	eval _x_fkeys='("${!'$_x_var'[@]}")'

	for _x_fkey in "${_x_fkeys[@]}"; do
		[[ $_x_fkey == *?: ]] || continue

		_x_keys+=("${_x_fkey:0:-1}")
	done

	eval $_x_target='("${_x_keys[@]}")'
}

map:fields () {
	[[ $# -eq 2 ]] || errorf || return

	local _x_var=$1 _x_target=$2 _x_fields && _var "$1" && _var "$2" || return

	if _debug; then
		is_hash "$_x_var" || warnf "Map variable is not an associative array"
		is_array "$_x_target" || warnf "Target variable is not an array"
	fi

	eval _x_fields=\${$_x_var[:]}

	[[ $_x_fields ]] || errorf "Map variable invalid" || return

	[[ $_x_fields != - ]] || errorf "Map variable is unstructured" || return

	eval $_x_target="($_x_fields)"
}

map:len () {
	[[ $# -ge 2 && $# -le 3 ]] || errorf || return

	local _x_var=$1 _x_target=$2 _x_key=$3 _x_len _x_keys && _var "$1" && _var "$2" || return

	! _debug || is_hash "$_x_var" || warnf "Map variable is not an associative array"

	if [[ $# -ge 3 ]]; then
		[[ $_x_key ]] || errorf "Illegal empty key" || return

		eval _x_len=\${$_x_var[\$_x_key:]}

		[[ $_x_len != _ ]] || errorf "Map variable is structured" || return

		[[ $_x_len ]] || _x_len=0
	else
		_x_len=0

		eval _x_keys='("${!'$_x_var'[@]}")'

		for _x_key in "${_x_keys[@]}"; do
			[[ $_x_key == *?: ]] && ((++_x_len))
		done
	fi

	eval $_x_target=$_x_len
}

tmp_file () {
	[[ $# -le 1 ]] || errorf || return

	local tmp tmpdir_arg=--tmpdir
	if [[ $# -ge 1 ]]; then
		[[ -d $1 ]] || errorf "Invalid target directory: $1" || return
		tmpdir_arg+==$1
	fi

	tmp=$(mktemp "$tmpdir_arg" --suffix .tmp tmp_$(uuidgen)_XXXXXXXX)

	_trace && trace "Temporary file: $tmp"

	run_exit rm -f "$tmp"

	TMP_FILE=$tmp
}

tmp_dir () {
	[[ $# -le 1 ]] || errorf || return

	local tmp tmpdir_arg=--tmpdir
	if [[ $# -ge 1 ]]; then
		[[ -d $1 ]] || errorf "Invalid target directory: $1" || return
		tmpdir_arg+==$1
	fi

	tmp=$(mktemp "$tmpdir_arg" --directory tmp_$(uuidgen)_XXXXXXXX)

	_trace && trace "Temporary directory: $tmp"

	run_exit rm -rf "$tmp"

	TMP_DIR=$tmp
}

require_command () {
	[[ $# -eq 1 ]] || errorf || return

	is_command "$1" || error "Command required: $1"
}

run () {
	[[ $# -gt 0 ]] || errorf || return

	if [[ $# -eq 1 && $1 == *' '* && $SHELL ]]; then
		set -- "$SHELL" -c "$1"
	fi

	_trace && trace "Running: $@"

	"$@"
}

run_job () {
	[[ $# -gt 0 ]] || errorf || return

	if [[ $# -eq 1 && $1 == *' '* && $SHELL ]]; then
		set -- "$SHELL" -c "$1"
	fi

	set -m

	"$@" &

	local pid=$(jobs -p % 2>/dev/null)

	[[ $pid ]] || return

	_trace && trace "Running job $pid: $@"

	run_exit kill_job $pid
}

kill_job () {
	[[ $# -le 1 ]] || errorf || return

	[[ $# -eq 0 ]] && set %

	local pid spec

	if valid_uint "$1"; then
		pid=$1

		local n pids=($(jobs -p))
		for ((n=1; n<=${#pids[@]}; n++)); do
			if [[ ${pids[n-1]} == $pid ]]; then
				spec=%$n
				break
			fi
		done
	else
		pid=$(jobs -p "$1" 2>/dev/null) && spec=$1
	fi

	if [[ ! $spec ]]; then
		_trace && trace "Job process not found: $1"

		return 0
	fi

	_trace && trace "Killing job process: $pid"

	kill "$spec" 2>/dev/null
	wait -f "$spec" 2>/dev/null
}

run_exit () {
	[[ $# -ge 1 ]] || errorf || return

	declare -g -a _run_exit_p _run_exit_s _run_exit_c

	_run_exit_p+=($BASHPID)
	_run_exit_s+=(${#@})
	_run_exit_c+=("$@")

	trap _run_exit_ EXIT
}


_run_exit_ () {
	_trace && trace "Running exit hooks start"

	local len
	while [[ ${#_run_exit_s[@]} -gt 0 ]]; do
		[[ ${_run_exit_p[-1]} == $BASHPID ]] || break

		_trace && trace "Running exit hook #${#_run_exit_s[@]}"

		len=${_run_exit_s[-1]}

		run "${_run_exit_c[@]: -len}" || :

		_run_exit_c=("${_run_exit_c[@]:0:${#_run_exit_c[@]}-len}")
		unset -v _run_exit_s[-1]
		unset -v _run_exit_p[-1]
	done

	_trace && trace "Running exit hooks done"

	return 0
}

coproc:run () {
	[[ $# -gt 1 && $1 ]] || errorf || return

	declare -g -A _coproc

	[[ ${_coproc[$1]} ]] && return

	local name=$1 && shift && valid_name "$name" || errorf "Invalid coprocess name" || return

	if [[ $# -eq 1 && $1 == *' '* && $SHELL ]]; then
		set -- "$SHELL" -c "$1"
	fi

	set -m

	coproc "$@"

	_coproc[$name]=$COPROC_PID
	_coproc[$name:0]=${COPROC[0]}
	_coproc[$name:1]=${COPROC[1]}

	_trace && trace "Running coprocess $COPROC_PID $name: $@"

	run_exit coproc:kill $name
}

coproc:kill () {
	[[ $# -eq 1 && $1 ]] || errorf || return

	local pid=${_coproc[$1]}

	[[ $pid ]] || errorf "Unknown coprocess" || return

	unset -v _coproc[$1] _coproc[$1:0] _coproc[$1:1]

	kill_job $pid
}

coproc:write () {
	[[ $# -gt 1 ]] || errorf || return

	local fd=${_coproc[$1:1]} && shift

	[[ $fd ]] || errorf "Unknown coprocess" || return

	if [[ $# -eq 0 ]]; then
		cat >&$fd
		return
	fi

	while [[ $# -gt 0 ]]; do
		echo -n "$1" >&$fd
		shift
	done
}

coproc:read_line () {
	[[ $# -eq 1 ]] || errorf || return

	local fd=${_coproc[$1:0]} && shift

	[[ $fd ]] || errorf "Unknown coprocess" || return

	IFS= read -r COPROC_DATA <&$fd || errorf "Failed reading line" || return
}

coproc:read_field () {
	[[ $# -eq 1 ]] || errorf || return

	local fd=${_coproc[$1:0]} && shift

	[[ $fd ]] || errorf "Unknown coprocess" || return

	local size end

	IFS= read -r size <&$fd || errorf "Failed reading field size" || return

	valid_uint "$size" || errorf "Invalid field size read: $size" || return

	IFS= read -r -d '' -n "$size" COPROC_DATA <&$fd || errorf "Failed reading field value" || return

	IFS= read -r end <&$fd || errorf "Failed reading field end" || return

	[[ ${#end} -eq 0 ]] || errorf "Unexpected data after field value" || return
}

@ () {
	local _x_var__

	__=_ @: _x_var__ "$@"

	local IFS=$'\n'

	echo "${_x_var__[*]}"
}

@- () {
	local _x_var__

	__=- @: _x_var__ "$@"

	local IFS=$'\n'

	echo "${_x_var__[*]}"
}

@@ () {
	local _x_var__

	__=@ @: _x_var__ "$@"

	local IFS=$'\n'

	echo "${_x_var__[*]}"
}

-@ () {
	local _x_var__ _x_ifs IFS=$IFS

	while IFS= read -r _x_var__; do
		__=- @: _x_var__ "$_x_var__" "$@"

		_x_ifs=$IFS IFS=$'\n'

		echo "${_x_var__[*]}"

		IFS=$_x_ifs
	done
}

-@@ () {
	local _x_var__

	readarray -t _x_var__

	__=@ @: _x_var__ _x_var__ "$@"

	local IFS=$'\n'

	echo "${_x_var__[*]}"
}

-@@: () {
	local _x_var=$1 _x_var__ && shift || errorf || return

	readarray -t _x_var__

	__=@ @: "$_x_var" _x_var__ "$@"
}

@@: () {
	__=@ @: "$@"
}

@:: () {
	__=@ @: "$1" "$@"
}

@: () {
	[[ $# -ge 3 ]] || errorf || return

	local _x_var=$1 _x_vals=($2) && _var "$1" && shift 2 || return

	local __=$__ _x_out__=() _x_in__=() _x_elems=() _x_sls=() _x_sls_x=() _x_vals_x=() _x_val _x_i _x_l _x_pos _x_len _x_size _x_depth _x_sld _x_sll _x_spec _x_fct _x_sep _x_arg _x_args=() _x_pipe=() _x_errexit _x_rc _x_funcname=$CALLER_FUNCNAME_

	[[ ! $__ || ${BASH_SOURCE[1]} != "$__functions" ]] && __=_

	while [[ ${#@} -gt 0 ]]; do
		_x_spec=$1 && shift

		if [[ $_x_spec == @* && ( ${_x_spec:1} != *[!-]* || ${_x_spec:1} != *[!+]* ) ]]; then
			_x_arg=$((${#_x_spec}-1))
			[[ $_x_spec == *- ]] && _x_arg=-$_x_arg

			_x_pipe+=(@ 1 $_x_arg)

			continue
		fi

		_x_fct=${_x_spec%%\[*}

		[[ $_x_fct ]] || errorf "Missing function name in argument: $_x_spec" || return

		is_pipeline "$_x_fct" || errorf "Function not a pipeline: $_x_fct" || return

		_x_spec=${_x_spec:${#_x_fct}} _x_args= _x_args=()

		if [[ $_x_spec ]]; then
			while :; do
				_x_sep=${_x_spec:0:1}
				_x_spec=${_x_spec:1}

				[[ $_x_sep == \] ]] && break

				if [[ $_x_sep == , ]]; then
					_x_args+=("$_x_arg")
				else
					[[ $_x_sep == \[ && ${#_x_args[@]} -eq 0 ]] || errorf "Missing comma separator after argument of function:" $_x_fct ${_x_args[@]} $_x_arg || return
				fi

				if [[ ! $_x_spec ]]; then
					_x_arg=$1 && shift || errorf "Missing isolated argument of function:" $_x_fct ${_x_args[@]} || return

					_x_spec=$1 && shift || errorf "Missing argument after isolated argument of function:" $_x_fct ${_x_args[@]} $_x_arg || return

					[[ $_x_spec == \]* ]] && _x_args+=("$_x_arg") && _x_arg=

					continue
				fi

				_x_arg=${_x_spec%%[,\]]*}
				_x_spec=${_x_spec:${#_x_arg}}
			done

			[[ ! $_x_spec ]] || errorf "Unexpected content '$_x_spec' after arguments of function:" $_x_fct ${_x_args[@]} || return

			[[ $_x_arg ]] && _x_args+=("$_x_arg")
		fi

		_x_pipe+=("$_x_fct" ${#_x_args[@]} "${_x_args[@]}")
	done

	shopt -qo errexit && _x_errexit=_

	if [[ $__ == - ]] || { [[ $__ == _ ]] && "$_x_pipe":__ _ -; }; then :; else
		_var "$_x_vals" || return

		eval _x_vals='("${'$_x_vals'[@]}")'
	fi

	_x_depth=1 _x_sls=(-1 ${#_x_vals[@]})

	while [[ ${#_x_pipe[@]} -gt 0 ]]; do
		_x_fct=${_x_pipe[0]}
		_x_len=${_x_pipe[1]}
		_x_args=("${_x_pipe[@]:2:_x_len}")
		_x_pipe=("${_x_pipe[@]:2+_x_len}")

		if [[ $_x_fct == @ ]]; then
			if [[ $_x_args -lt 0 ]]; then
				[[ -$_x_depth -lt $_x_args ]] && _x_depth=$((_x_depth+_x_args)) || _x_depth=1
			else
				[[ $_x_depth -gt $_x_args ]] && _x_depth=$((_x_args+1))
			fi
			continue
		fi

		"$_x_fct":__ @ - && _x_sld=$((_x_depth+1)) || _x_sld=

		_x_pos=0 _x_l=${#_x_sls[@]}

		for ((_x_i=0; _x_i<_x_l; _x_i++)); do
			_x_len=${_x_sls[_x_i]}

			if [[ $_x_len -lt 0 ]]; then
				[[ -$_x_len -lt $_x_depth ]] && _x_sls_x+=($_x_len) && continue
				[[ -$_x_len -gt $_x_depth ]] || continue

				_x_len=0

				while :; do
					_x_sll=${_x_sls[_x_i+1]}

					if [[ $_x_sll -lt 0 ]]; then
						[[ -$_x_sll -gt $_x_depth ]] || break
					else
						_x_len=$((_x_len+_x_sll))
					fi

					((++_x_i))

					[[ $_x_i -ge $_x_l ]] && ((_x_i--)) && break
				done
			fi

			_x_sls_x+=(-$_x_depth)

			if "$_x_fct":__ _ -; then
				_x_elems=("${_x_vals[@]:_x_pos:_x_len}")
			else
				_x_in__=("${_x_vals[@]:_x_pos:_x_len}")
				_x_elems=(_x_in__)
			fi

			_x_size=${#_x_vals_x[@]}

			[[ $_x_sld ]] && _x_sls_x+=(-$_x_sld)

			for _x_val in "${_x_elems[@]}"; do
				[[ $_x_funcname ]] || CALLER_FUNCNAME_=$_x_fct

				[[ $_x_errexit ]] && set +e

				"$_x_fct": _x_out__ "$_x_val" "${_x_args[@]}"

				_x_rc=$?

				[[ $_x_errexit ]] && set -e

				[[ $_x_funcname ]] || unset -v CALLER_FUNCNAME_

				[[ $_x_errexit && $_x_rc -ne 0 ]] && return $_x_rc

				_x_vals_x+=("${_x_out__[@]}") _x_out__=()

				[[ $_x_sld ]] && _x_sls_x+=($((${#_x_vals_x[@]}-_x_size))) && _x_size=${#_x_vals_x[@]}
			done

			[[ $_x_sld ]] || _x_sls_x+=($((${#_x_vals_x[@]}-_x_size)))

			_x_pos=$((_x_pos+_x_len))
		done

		_x_sls=("${_x_sls_x[@]}") _x_sls_x=()
		_x_vals=("${_x_vals_x[@]}") _x_vals_x=()

		if [[ $_x_sld ]]; then
			_x_depth=$_x_sld
		elif "$_x_fct":__ - @; then
			((_x_depth--))
		fi
	done

	if [[ ${#_x_vals[@]} -ne 1 ]]; then
		eval $_x_var='("${_x_vals[@]}")'
	else
		eval _x_len=\${#$_x_var[@]}

		if [[ $_x_len -gt 1 ]]; then
			eval $_x_var='("$_x_vals")'
		else
			eval $_x_var=\$_x_vals
		fi
	fi
}

_caller () {
	local source depth len=${#FUNCNAME[@]}

	for ((depth=2; depth<len; depth++)); do
		source=${BASH_SOURCE[depth]}

		[[ $source != "$__functions" ]] && break
	done

	[[ $depth -lt $len ]] || source=$0

	[[ $CALLER_SOURCE_ ]] && CALLER_SOURCE=$CALLER_SOURCE_ || \
		CALLER_SOURCE=$source

	[[ $CALLER_LINENO_ ]] && CALLER_LINENO=$CALLER_LINENO_ || \
		CALLER_LINENO=${BASH_LINENO[depth-1]}

	[[ $CALLER_FUNCNAME_ ]] && CALLER_FUNCNAME=$CALLER_FUNCNAME_ || \
		CALLER_FUNCNAME=${FUNCNAME[depth-1]}
}

_caller_ () {
	unset -v CALLER_SOURCE CALLER_LINENO CALLER_FUNCNAME
}

_var () {
	valid_name "$1" || errorf "Illegal name '$1' for variable" || return

	[[ $1 != _x_* || $1 == *_ ]] || errorf "Conflicting name '$1' for variable" || return

	return 0
}

__functions () {
	local args fct name proto out_ini out_val in_ini in_set in_val

	while read -r -a args; do
		fct=${args[-1]}

		[[ $fct =~ ^([^\]\[]*[^:]):\[(.*)\]$ ]] || continue

		name=${BASH_REMATCH[1]} proto=${BASH_REMATCH[2]}

		case ${proto:0:1} in
		-)
			out_ini=
			out_val=\$_x_var_
			;;
		@)
			out_ini='()'
			out_val=\${_x_var_[*]}
			;;
		*)
			_debug && warn "Invalid function prototype output argument: $fct"
			continue
			;;
		esac
		case ${proto:1:1} in
		-)
			in_ini=
			in_set='\$$_x_var_'
			in_val=\$_x_val_
			;;
		@)
			in_ini='()'
			in_set=\''("${'\'\$_x_var_\''[@]}")'\'
			in_val=_x_val_
			;;
		*)
			_debug && warn "Invalid function prototype input argument: $fct" ;;
		esac

		_debug && [[ ${#proto} -gt 2 ]] && warn "Invalid function prototype arguments: $fct"

		eval '
			'"$name"':__ () {
				local i arg type proto='"$proto"'

				for arg; do
					[[ $proto ]] || return 1

					type=${proto:0:1} proto=${proto:1}

					for ((i=0; i<${#arg}; i++)); do
						[[ ${arg:i:1} == [_$type] ]] && continue 2
					done

					return 1
				done

				return 0
			}

			'"$name"': () {
				'"$fct"' "$@"
			}

			'"$name"':: () {
				[[ $# -gt 0 ]] || errorf || return

				local _x_var_=$1 _x_val_='"$in_ini"'

				_var "$1" && shift || return

				eval _x_val_='"$in_set"'

				'"$fct"' $_x_var_ "'"$in_val"'" "$@"
			}

			'"$name"' () {
				local _x_var_='"$out_ini"'

				'"$fct"' _x_var_ "$@"

				local IFS=$'\''\n'\''

				echo "'"$out_val"'"
			}
		'
	done < <(
		declare -F
	)
}

__functions && __functions__=_
